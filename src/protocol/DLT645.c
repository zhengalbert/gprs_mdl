/******************************************************************************
 Copyright (C) 2010  R&D Institute of HuaCai Co.,Ltd.
 File Name      : DLT645.c
 Description    : DTL645通信规约
-------------------------------------------------------------------------------
 Modification History:
 <No.>  <version>       <time>      <author>        <contents>
   2、
   1、    1.00        2010-09-01    LJL          the original version
******************************************************************************/
#include    "..\inc\global_config.h"
#include    "..\src\bsp\event_define_d.h"               //有关事件宏的定义
//
//extern U8 Sample_Data[];
//------------------------------ 私有变量声明 ---------------------------------
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
static U8 prg_record_state;                                             //编程记录状态字
static S32 deal_with_after_frame(U8 *obj_buff, U8 *rev_buff);           //后续帧处理
#endif
//static U8 baud_change_flag;                                             //波特率修改标识
static U16 radio_date;                                                  //广播校时后保存的日期
static VU8 after_fram_flag;                                             //有后续帧标志
static VU32 prg_en_tick;                                                //打开编程状态的时间
static VU32 prg_en_time;
//------------------------------ 私有函数声明 -------------------------------
static U8 check_password (U8 *obj_buff);                                //检测密码权限
static U8 check_radio_time_valid(U8 *time);                             //检测广播校时时间有效性
static S32 deal_with_energy_frame(U8 *obj_buff, U8 *rev_buff);          //电能量帧处理
static S32 deal_with_demand_frame(U8 *obj_buff, U8 *rev_buff);          //需量帧处理
static S32 deal_with_variable_frame(U8 *obj_buff, U8 *rev_buff);        //变量帧处理
// static S32 deal_with_event_record_frame(U8 *obj_buff, U8 *rev_buff);    //事件记录帧处理
static S32 read_parameter_frame(U8 *obj_buff, U8 *rev_buff);            //参变量帧读
static S32 write_parameter_frame(U8 *obj_buff, U8 *rev_buff, U8 pswd);  //参变量帧写
static S32 deal_with_freeze_frame(U8 *obj_buff, U8 *rev_buff);          //冻结帧处理

static S32 deal_with_err_frame(U8 *rev_buff, U8 flag);                  //错误帧处理
static S32 set_password(U8 *obj_buff, U8 *rev_buff);                    //修改密码
// static S32 set_produce_para(U8 *obj_buff, U8 *rev_buff, U8 pswd);       //厂家设置
static S32 deal_program_enable(U8 *obj_buff, U8 *rev_buff, U8 pswd);    //打开编程状态
static S32 write_produce_frame(U8 *obj_buff, U8 *rev_buff, U8 pswd);   //写厂家扩充的规约
static S8 deal_with_initiative_frame(U8 *rcv);
static S8 deal_with_energy (U8 *rcv);
static S8 deal_with_demand(U8 *rcv);
static S8 deal_with_variable(U8 *rcv);
static S8 read_parameter(U8 *rcv);
static S8 read_event(U8 *rcv);
static S8 read_freeze(U8 *rcv);
static S8 read_load_profile(U8 *rcv);
static S8 deal_with_manufacturer(U8 *rcv);

//azh 上面这个fil表格会在升级时重新清除掉 所以不能挪到其他地方 而且常数区域又不放不上 所以把下面这个小一点的表格挪到其他地方去
////显示方案数据
//const U8 fixchar_table[FIXCHAR_TABLE_MAXNUM][8] =
//{
//    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x10,0x32,0x10,0x80,0x00    },
//    {0x00,0x00,0x00,0x10,0x02,0x20,0x01,0x00    },
//    {0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x10,0x04,0x00,0x04,0x00    },
//    {0x01,0x40,0x80,0x01,0x08,0x08,0x00,0x00    },
//    {0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00    },
//    {0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00    },
//    {0x60,0x43,0x00,0x28,0x00,0x00,0x00,0x00    },
//    {0x60,0x03,0x00,0x28,0x00,0x14,0x00,0x00    },
//    {0x60,0x03,0x00,0x28,0x30,0x00,0x00,0x00    },
//    {0x08,0x03,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x08,0x43,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x08,0x03,0x00,0x00,0x30,0x00,0x00,0x00    },
//    {0x08,0x03,0x00,0x00,0x00,0x14,0x00,0x00    },
//    {0x00,0x03,0x00,0x00,0x00,0x00,0x04,0x00    },
//    {0x01,0x43,0x00,0x00,0x08,0x04,0x03,0x00    },
//    {0x00,0x40,0x00,0x28,0x00,0x00,0x00,0x00    },
//    {0x60,0x43,0x00,0x28,0x30,0x10,0x80,0x00    },
//    {0x60,0x43,0x00,0x28,0x00,0x14,0x00,0x00    },
//    {0x60,0x43,0x00,0x28,0x00,0x01,0x05,0x00    },
//    {0x50,0x43,0x00,0x28,0x30,0x10,0x80,0x00    },
//    {0x50,0x43,0x00,0x28,0x00,0x14,0x00,0x00    },
//    {0x50,0x43,0x00,0x28,0x00,0x01,0x05,0x00    },
//    {0x80,0x42,0x00,0x28,0x30,0x10,0x80,0x00    },
//    {0x80,0x42,0x00,0x28,0x00,0x14,0x00,0x00    },
//    {0x80,0x42,0x00,0x28,0x00,0x01,0x05,0x00    },
//    {0x60,0x43,0x20,0x28,0x30,0x10,0x80,0x00    },
//    {0x60,0x43,0x20,0x28,0x00,0x14,0x00,0x00    },
//    {0x60,0x43,0x20,0x28,0x00,0x01,0x05,0x00    },
//    {0x50,0x43,0x20,0x28,0x30,0x10,0x80,0x00    },
//    {0x50,0x43,0x20,0x28,0x00,0x14,0x00,0x00    },
//    {0x50,0x43,0x20,0x28,0x00,0x01,0x05,0x00    },
//    {0x80,0x42,0x20,0x28,0x30,0x10,0x80,0x00    },
//    {0x80,0x42,0x20,0x28,0x00,0x14,0x00,0x00    },
//    {0x80,0x42,0x20,0x28,0x00,0x01,0x05,0x00    },
//    {0x60,0x43,0x10,0x28,0x30,0x10,0x80,0x00    },
//    {0x60,0x43,0x10,0x28,0x00,0x14,0x00,0x00    },
//    {0x60,0x43,0x10,0x28,0x00,0x01,0x05,0x00    },
//    {0x50,0x43,0x10,0x28,0x30,0x10,0x80,0x00    },
//    {0x50,0x43,0x10,0x28,0x00,0x14,0x00,0x00    },
//    {0x50,0x43,0x10,0x28,0x00,0x01,0x05,0x00    },
//    {0x80,0x42,0x10,0x28,0x30,0x10,0x80,0x00    },
//    {0x80,0x42,0x10,0x28,0x00,0x14,0x00,0x00    },
//    {0x80,0x42,0x10,0x28,0x00,0x01,0x05,0x00    },
//    {0x60,0x43,0x08,0x28,0x30,0x10,0x80,0x00    },
//    {0x60,0x43,0x08,0x28,0x00,0x14,0x00,0x00    },
//    {0x60,0x43,0x08,0x28,0x00,0x01,0x05,0x00    },
//    {0x50,0x43,0x08,0x28,0x30,0x10,0x80,0x00    },
//    {0x50,0x43,0x08,0x28,0x00,0x14,0x00,0x00    },
//    {0x50,0x43,0x08,0x28,0x00,0x01,0x05,0x00    },
//    {0x80,0x42,0x08,0x28,0x30,0x10,0x80,0x00    },
//    {0x80,0x42,0x08,0x28,0x00,0x14,0x00,0x00    },
//    {0x80,0x42,0x08,0x28,0x00,0x01,0x05,0x00    },
//    {0x00,0x00,0x00,0x28,0x30,0x14,0xC0,0x00    },
//    {0x00,0x00,0x00,0x28,0x00,0x14,0x00,0x00    },
//    {0x60,0x03,0x00,0x28,0x00,0x00,0x00,0x00    },
//    {0x60,0x03,0x00,0x28,0x00,0x00,0x10,0x00    },
//    {0x50,0x03,0x00,0x28,0x30,0x00,0x00,0x00    },
//    {0x50,0x03,0x00,0x28,0x00,0x14,0x00,0x00    },
//    {0x50,0x03,0x00,0x28,0x00,0x00,0x10,0x00    },
//    {0x00,0x00,0x00,0x00,0x30,0x14,0xC0,0x00    },
//    {0x00,0x00,0x00,0x28,0x08,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00    },
//    {0x88,0x02,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x88,0x02,0x00,0x00,0x30,0x00,0x00,0x00    },
//    {0x88,0x02,0x00,0x00,0x00,0x14,0x00,0x00    },
//    {0x88,0x42,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x80,0x02,0x00,0x00,0x00,0x00,0x04,0x00    },
//    {0x01,0x00,0x00,0x10,0x02,0x10,0x02,0x00    },
//    {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x81,0x42,0x00,0x00,0x08,0x04,0x10,0x00    },
//    {0x01,0x40,0x00,0x00,0x08,0x04,0x05,0x00    },
//    {0x01,0x03,0x20,0x00,0x08,0x04,0x03,0x00    },
//    {0x81,0x02,0x20,0x00,0x08,0x04,0x10,0x00    },
//    {0x01,0x00,0x20,0x00,0x08,0x04,0x05,0x00    },
//    {0x01,0x03,0x10,0x00,0x08,0x04,0x03,0x00    },
//    {0x81,0x02,0x10,0x00,0x08,0x04,0x10,0x00    },
//    {0x01,0x00,0x10,0x00,0x08,0x04,0x05,0x00    },
//    {0x01,0x03,0x08,0x00,0x08,0x04,0x03,0x00    },
//    {0x81,0x02,0x08,0x00,0x08,0x04,0x10,0x00    },
//    {0x01,0x00,0x08,0x00,0x08,0x04,0x05,0x00    },
//    {0x00,0x03,0x20,0x00,0x0B,0x10,0x03,0x00    },
//    {0x80,0x02,0x20,0x00,0x0B,0x10,0x0D,0x00    },
//    {0x00,0x00,0xA0,0x01,0x0B,0x08,0x00,0x00    },
//    {0x00,0x00,0x20,0x10,0x03,0x20,0x01,0x00    },
//    {0x00,0x00,0x20,0x10,0x07,0x10,0x0C,0x00    },
//    {0x00,0x03,0x10,0x00,0x0B,0x10,0x03,0x00    },
//    {0x80,0x02,0x10,0x00,0x0B,0x10,0x0D,0x00    },
//    {0x00,0x00,0x90,0x01,0x0B,0x08,0x00,0x00    },
//    {0x00,0x00,0x10,0x10,0x03,0x20,0x01,0x00    },
//    {0x00,0x00,0x10,0x10,0x07,0x10,0x0C,0x00    },
//    {0x00,0x03,0x08,0x00,0x0B,0x10,0x03,0x00    },
//    {0x80,0x02,0x08,0x00,0x0B,0x10,0x0D,0x00    },
//    {0x00,0x00,0x88,0x01,0x0B,0x08,0x00,0x00    },
//    {0x00,0x00,0x08,0x10,0x03,0x20,0x01,0x00    },
//    {0x00,0x00,0x08,0x10,0x07,0x10,0x0C,0x00    },
//    {0x88,0x42,0x00,0x30,0x03,0x10,0x0D,0x00    },
//    {0x00,0x40,0x00,0x00,0x03,0x10,0x0C,0x00    },
//    {0x60,0x43,0x00,0x30,0x03,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x30,0x03,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x30,0x03,0x10,0x0D,0x00    },
//    {0x60,0x03,0x20,0x30,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x30,0x03,0x10,0x0B,0x00    },
//    {0x00,0x00,0x20,0x00,0x03,0x10,0x0C,0x00    },
//    {0x88,0x02,0x10,0x30,0x03,0x10,0x0D,0x00    },
//    {0x60,0x03,0x10,0x30,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x30,0x03,0x10,0x0B,0x00    },
//    {0x00,0x00,0x10,0x00,0x03,0x10,0x0C,0x00    },
//    {0x88,0x02,0x08,0x30,0x03,0x10,0x0D,0x00    },
//    {0x60,0x03,0x08,0x30,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x30,0x03,0x10,0x0B,0x00    },
//    {0x00,0x00,0x08,0x00,0x03,0x10,0x0C,0x00    },
//    {0x00,0x03,0x20,0x00,0x0D,0x10,0x03,0x00    },
//    {0x80,0x02,0x20,0x00,0x0D,0x10,0x0D,0x00    },
//    {0x00,0x00,0xA0,0x01,0x0D,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x10,0x07,0x20,0x01,0x00    },
//    {0x00,0x00,0x20,0x10,0x05,0x10,0x0C,0x00    },
//    {0x00,0x03,0x10,0x00,0x0D,0x10,0x03,0x00    },
//    {0x80,0x02,0x10,0x00,0x0D,0x10,0x0D,0x00    },
//    {0x00,0x00,0x90,0x01,0x0D,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x10,0x07,0x20,0x01,0x00    },
//    {0x00,0x00,0x10,0x10,0x05,0x10,0x0C,0x00    },
//    {0x00,0x03,0x08,0x00,0x0D,0x10,0x03,0x00    },
//    {0x80,0x02,0x08,0x00,0x0D,0x10,0x0D,0x00    },
//    {0x00,0x00,0x88,0x01,0x0D,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x10,0x07,0x20,0x01,0x00    },
//    {0x00,0x00,0x08,0x10,0x05,0x10,0x0C,0x00    },
//    {0x88,0x42,0x00,0x30,0x05,0x10,0x0D,0x00    },
//    {0x60,0x43,0x00,0x30,0x05,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x30,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x30,0x05,0x10,0x0D,0x00    },
//    {0x60,0x03,0x20,0x30,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x30,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x30,0x05,0x10,0x0D,0x00    },
//    {0x60,0x03,0x10,0x30,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x30,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x30,0x05,0x10,0x0D,0x00    },
//    {0x60,0x03,0x08,0x30,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x30,0x05,0x10,0x0B,0x00    },
//    {0x00,0x40,0x00,0x00,0x33,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x00,0x03,0x00,0x00,0x00    },
//    {0x00,0x03,0x20,0x00,0x0A,0x10,0x03,0x00    },
//    {0x80,0x02,0x20,0x00,0x0A,0x10,0x0D,0x00    },
//    {0x00,0x00,0xA0,0x01,0x0A,0x00,0x00,0x00    },
//    {0x00,0x00,0xA0,0x01,0x0A,0x08,0x00,0x00    },
//    {0x00,0x00,0x20,0x10,0x02,0x20,0x01,0x00    },
//    {0x00,0x00,0x20,0x10,0x06,0x10,0x0C,0x00    },
//    {0x00,0x03,0x10,0x00,0x0A,0x10,0x03,0x00    },
//    {0x80,0x02,0x10,0x00,0x0A,0x10,0x0D,0x00    },
//    {0x00,0x00,0x90,0x01,0x0A,0x08,0x00,0x00    },
//    {0x00,0x00,0x90,0x01,0x0A,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x10,0x02,0x20,0x01,0x00    },
//    {0x00,0x00,0x10,0x10,0x06,0x10,0x0C,0x00    },
//    {0x00,0x03,0x08,0x00,0x0A,0x10,0x03,0x00    },
//    {0x80,0x02,0x08,0x00,0x0A,0x10,0x0D,0x00    },
//    {0x00,0x00,0x88,0x01,0x0A,0x08,0x00,0x00    },
//    {0x00,0x00,0x88,0x01,0x0A,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x10,0x02,0x20,0x01,0x00    },
//    {0x00,0x00,0x08,0x10,0x06,0x10,0x0C,0x00    },
//    {0x88,0x42,0x00,0x30,0x02,0x10,0x0D,0x00    },
//    {0x00,0x40,0x00,0x00,0x02,0x10,0x0C,0x00    },
//    {0x60,0x43,0x00,0x30,0x02,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x30,0x02,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x30,0x02,0x10,0x0D,0x00    },
//    {0x60,0x03,0x20,0x30,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x30,0x02,0x10,0x0B,0x00    },
//    {0x00,0x00,0x20,0x00,0x02,0x10,0x0C,0x00    },
//    {0x88,0x02,0x10,0x30,0x02,0x10,0x0D,0x00    },
//    {0x60,0x03,0x10,0x30,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x30,0x02,0x10,0x0B,0x00    },
//    {0x00,0x00,0x10,0x00,0x02,0x10,0x0C,0x00    },
//    {0x88,0x02,0x08,0x30,0x02,0x10,0x0D,0x00    },
//    {0x60,0x03,0x08,0x30,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x30,0x02,0x10,0x0B,0x00    },
//    {0x00,0x00,0x08,0x00,0x02,0x10,0x0C,0x00    },
//    {0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00    },
//    {0x01,0x00,0x00,0x10,0x04,0x08,0x04,0x00    },
//    {0x00,0x00,0x00,0x00,0x80,0x14,0xC0,0x00    },
//    {0x00,0x00,0x00,0x00,0x50,0x14,0x00,0x00    },
//    {0x60,0x43,0x00,0x30,0x00,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x30,0x00,0x10,0x0B,0x00    },
//    {0x80,0x42,0x00,0x30,0x00,0x10,0x0D,0x00    },
//    {0x00,0x00,0x00,0x00,0x30,0x10,0x00,0x00    },
//    {0x50,0x43,0x00,0x30,0x00,0x00,0x0B,0x00    },
//    {0x80,0x42,0x00,0x30,0x00,0x00,0x0D,0x00    },
//    {0x80,0x42,0x00,0x30,0x00,0x14,0xCD,0x00    },
//    {0x60,0x43,0x00,0x30,0x00,0x00,0x0B,0x00    },
//    {0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00    },
//    {0x88,0x42,0x00,0x30,0x00,0x10,0x0D,0x00    },
//    {0x00,0x43,0x00,0x30,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x30,0x00,0x10,0x0D,0x00    },
//    {0x60,0x03,0x20,0x30,0x00,0x10,0x0B,0x00    },
//    {0x00,0x03,0x20,0x30,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x30,0x00,0x10,0x0D,0x00    },
//    {0x60,0x03,0x10,0x30,0x00,0x10,0x0B,0x00    },
//    {0x00,0x03,0x10,0x30,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x30,0x00,0x10,0x0D,0x00    },
//    {0x60,0x03,0x08,0x30,0x00,0x10,0x0B,0x00    },
//    {0x00,0x03,0x08,0x30,0x00,0x10,0x0B,0x00    },
//    {0x10,0x03,0x08,0x30,0x00,0x10,0x0B,0x00    },
//    {0x00,0x03,0x20,0x00,0x0C,0x10,0x03,0x00    },
//    {0x80,0x02,0x20,0x00,0x0C,0x10,0x0D,0x00    },
//    {0x00,0x00,0xA0,0x01,0x0C,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x10,0x06,0x20,0x01,0x00    },
//    {0x00,0x00,0x20,0x10,0x04,0x10,0x0C,0x00    },
//    {0x00,0x03,0x10,0x00,0x0C,0x10,0x03,0x00    },
//    {0x80,0x02,0x10,0x00,0x0C,0x10,0x0D,0x00    },
//    {0x00,0x00,0x90,0x01,0x0C,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x10,0x06,0x20,0x01,0x00    },
//    {0x00,0x00,0x10,0x10,0x04,0x10,0x0C,0x00    },
//    {0x00,0x03,0x08,0x00,0x0C,0x10,0x03,0x00    },
//    {0x80,0x02,0x08,0x00,0x0C,0x10,0x0D,0x00    },
//    {0x00,0x00,0x88,0x01,0x0C,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x10,0x06,0x20,0x01,0x00    },
//    {0x00,0x00,0x08,0x10,0x04,0x10,0x0C,0x00    },
//    {0x88,0x42,0x00,0x30,0x04,0x10,0x0D,0x00    },
//    {0x60,0x43,0x00,0x30,0x04,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x30,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x30,0x04,0x10,0x0D,0x00    },
//    {0x60,0x03,0x20,0x30,0x04,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x30,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x30,0x04,0x10,0x0D,0x00    },
//    {0x60,0x03,0x10,0x30,0x04,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x30,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x30,0x04,0x10,0x0D,0x00    },
//    {0x60,0x03,0x08,0x30,0x04,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x30,0x04,0x10,0x0B,0x00    },
//    {0x00,0x00,0x00,0x00,0x30,0x10,0x80,0x00    },
//    {0x00,0x40,0x00,0x10,0x31,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x10,0x01,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00    },
//    {0x50,0x43,0x00,0x28,0x00,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x10,0x02,0x00,0x04,0x00    },
//    {0x00,0x03,0x20,0x00,0x08,0x10,0x03,0x00    },
//    {0x80,0x02,0x20,0x00,0x08,0x10,0x0D,0x00    },
//    {0x00,0x00,0xA0,0x01,0x08,0x00,0x00,0x00    },
//    {0x00,0x03,0x10,0x00,0x08,0x10,0x03,0x00    },
//    {0x80,0x02,0x10,0x00,0x08,0x10,0x0D,0x00    },
//    {0x00,0x00,0x90,0x01,0x08,0x00,0x00,0x00    },
//    {0x00,0x03,0x08,0x00,0x08,0x10,0x03,0x00    },
//    {0x80,0x02,0x08,0x00,0x08,0x10,0x0D,0x00    },
//    {0x00,0x00,0x88,0x01,0x08,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x00,0x00,0x10,0x0C,0x00    },
//    {0x50,0x03,0x20,0x30,0x00,0x10,0x0B,0x00    },
//    {0x00,0x00,0x20,0x00,0x00,0x10,0x0C,0x00    },
//    {0x50,0x03,0x10,0x30,0x00,0x10,0x0B,0x00    },
//    {0x00,0x00,0x10,0x00,0x00,0x10,0x0C,0x00    },
//    {0x50,0x03,0x08,0x30,0x00,0x10,0x0B,0x00    },
//    {0x00,0x00,0x08,0x00,0x00,0x10,0x0C,0x00    },
//    {0x00,0x40,0x00,0x10,0x00,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x10,0x32,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x10,0x02,0x00,0x00,0x00    },
//    {0x88,0x02,0x00,0x30,0x02,0x10,0x0D,0x00    },
//    {0x60,0x03,0x00,0x30,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x00,0x30,0x02,0x10,0x0B,0x00    },
//    {0x00,0x00,0x00,0x10,0x32,0x00,0x00,0x00    },
//    {0x00,0x00,0x00,0x10,0x02,0x00,0x00,0x00    },
//    {0x02,0x00,0x00,0x10,0x32,0x00,0x00,0x00    },
//    {0x60,0x03,0x00,0x30,0x02,0x10,0x0F,0x00    },
//    {0x50,0x03,0x00,0x30,0x02,0x10,0x0F,0x00    },
//    {0x01,0x00,0x00,0x00,0x00,0x10,0x00,0x00    },
//    {0x00,0x40,0x00,0x10,0x34,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x10,0x04,0x00,0x00,0x00    },
//    {0x88,0x02,0x00,0x30,0x04,0x10,0x0D,0x00    },
//    {0x60,0x03,0x00,0x30,0x04,0x10,0x0B,0x00    },
//    {0x50,0x03,0x00,0x30,0x04,0x10,0x0B,0x00    },
//    {0x60,0x03,0x00,0x30,0x04,0x10,0x0F,0x00    },
//    {0x50,0x03,0x00,0x30,0x04,0x10,0x0F,0x00    },
//    {0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00    },
//    {0x00,0x03,0x00,0x10,0x00,0x00,0x0B,0x00    },
//    {0x00,0x00,0x00,0x10,0x00,0x00,0x04,0x00    },
//    {0x80,0x02,0x00,0x10,0x00,0x00,0x18,0x00    },
//    {0x80,0x02,0x20,0x30,0x00,0x10,0x0D,0x00    },
//    {0x80,0x02,0x10,0x30,0x00,0x10,0x0D,0x00    },
//    {0x80,0x02,0x08,0x30,0x00,0x10,0x0D,0x00    },
//    {0x00,0x00,0x00,0x10,0x30,0x14,0xC0,0x00    },
//    {0x00,0x00,0x00,0x10,0x00,0x14,0x00,0x00    },
//    {0x80,0x02,0x00,0x28,0x30,0x00,0x00,0x00    },
//    {0x80,0x02,0x00,0x28,0x00,0x14,0x00,0x00    },
//    {0x01,0x03,0x00,0x28,0x00,0x04,0x03,0x00    },
//    {0x81,0x02,0x00,0x28,0x00,0x04,0x10,0x00    },
//    {0x01,0x00,0x00,0x28,0x00,0x04,0x05,0x00    },
//    {0xD8,0x42,0x00,0x30,0x04,0x10,0x0D,0x00    },
//    {0x70,0x43,0x00,0x30,0x04,0x10,0x0B,0x00    },
//    {0xD8,0x02,0x20,0x30,0x04,0x10,0x0D,0x00    },
//    {0x70,0x03,0x20,0x30,0x04,0x10,0x0B,0x00    },
//    {0xD8,0x02,0x10,0x30,0x04,0x10,0x0D,0x00    },
//    {0x70,0x03,0x10,0x30,0x04,0x10,0x0B,0x00    },
//    {0xD8,0x02,0x08,0x30,0x04,0x10,0x0D,0x00    },
//    {0x70,0x03,0x08,0x30,0x04,0x10,0x0B,0x00    },
//    {0x00,0x00,0x00,0x00,0x00,0x14,0xC0,0x00    },
//    {0x01,0x00,0x00,0x00,0x00,0x20,0x00,0x00    },
//    {0x00,0x00,0x20,0x10,0x32,0x10,0x80,0x00    },
//    {0x01,0x00,0x20,0x00,0x00,0x20,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x03,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x00,0x33,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x00,0x33,0x14,0xC0,0x00    },
//    {0x00,0x00,0x20,0x00,0x03,0x14,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x35,0x00,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x05,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x00,0x35,0x14,0xC0,0x00    },
//    {0x00,0x00,0x20,0x00,0x05,0x14,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x32,0x00,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x02,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x00,0x32,0x14,0xC0,0x00    },
//    {0x00,0x00,0x20,0x00,0x02,0x14,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x30,0x00,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x00,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x00,0x30,0x14,0xC0,0x00    },
//    {0x00,0x00,0x20,0x00,0x00,0x14,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x34,0x00,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x04,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x00,0x34,0x14,0xC0,0x00    },
//    {0x00,0x00,0x20,0x00,0x04,0x14,0x00,0x00    },
//    {0x01,0x00,0xA0,0x01,0x08,0x08,0x00,0x00    },
//    {0x00,0x00,0x20,0x10,0x32,0x00,0x00,0x00    },
//    {0x00,0x00,0x20,0x10,0x02,0x00,0x00,0x00    },
//    {0x02,0x00,0x20,0x10,0x32,0x00,0x00,0x00    },
//    {0x01,0x00,0x20,0x10,0x03,0x10,0x00,0x00    },
//    {0x01,0x00,0x20,0x10,0x02,0x20,0x01,0x00    },
//    {0x01,0x00,0x20,0x10,0x05,0x10,0x00,0x00    },
//    {0x01,0x00,0x20,0x10,0x04,0x08,0x04,0x00    },
//    {0x50,0x40,0x20,0x00,0x34,0x00,0x00,0x00    },
//    {0x50,0x40,0x20,0x00,0x04,0x00,0x00,0x00    },
//    {0x50,0x00,0x20,0x00,0x34,0x14,0xC0,0x00    },
//    {0x50,0x00,0x20,0x00,0x04,0x14,0x00,0x00    },
//    {0x00,0x00,0x10,0x10,0x32,0x10,0x80,0x00    },
//    {0x01,0x00,0x10,0x00,0x00,0x20,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x33,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x03,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x00,0x03,0x14,0x00,0x00    },
//    {0x00,0x00,0x10,0x00,0x33,0x14,0xC0,0x00    },
//    {0x00,0x40,0x10,0x00,0x35,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x05,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x00,0x35,0x14,0xC0,0x00    },
//    {0x00,0x00,0x10,0x00,0x05,0x14,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x32,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x02,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x00,0x32,0x14,0xC0,0x00    },
//    {0x00,0x00,0x10,0x00,0x02,0x14,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x30,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x00,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x00,0x30,0x14,0xC0,0x00    },
//    {0x00,0x00,0x10,0x00,0x00,0x14,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x34,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x04,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x00,0x34,0x14,0xC0,0x00    },
//    {0x00,0x00,0x10,0x00,0x04,0x14,0x00,0x00    },
//    {0x01,0x00,0x90,0x01,0x08,0x08,0x00,0x00    },
//    {0x00,0x00,0x10,0x10,0x02,0x00,0x00,0x00    },
//    {0x00,0x00,0x10,0x10,0x32,0x00,0x00,0x00    },
//    {0x02,0x00,0x10,0x10,0x32,0x00,0x00,0x00    },
//    {0x01,0x00,0x10,0x10,0x03,0x10,0x00,0x00    },
//    {0x01,0x00,0x10,0x10,0x02,0x20,0x01,0x00    },
//    {0x01,0x00,0x10,0x10,0x05,0x10,0x00,0x00    },
//    {0x01,0x00,0x10,0x10,0x04,0x08,0x04,0x00    },
//    {0x50,0x40,0x10,0x00,0x34,0x00,0x00,0x00    },
//    {0x50,0x40,0x10,0x00,0x04,0x00,0x00,0x00    },
//    {0x50,0x00,0x10,0x00,0x34,0x14,0xC0,0x00    },
//    {0x50,0x00,0x10,0x00,0x04,0x14,0x00,0x00    },
//    {0x00,0x00,0x08,0x10,0x32,0x10,0x80,0x00    },
//    {0x01,0x00,0x08,0x00,0x00,0x20,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x33,0x00,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x03,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x00,0x33,0x14,0xC0,0x00    },
//    {0x00,0x00,0x08,0x00,0x03,0x14,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x35,0x00,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x05,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x00,0x35,0x14,0xC0,0x00    },
//    {0x00,0x00,0x08,0x00,0x05,0x14,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x32,0x00,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x02,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x00,0x32,0x14,0xC0,0x00    },
//    {0x00,0x00,0x08,0x00,0x02,0x14,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x30,0x00,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x00,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x00,0x30,0x14,0xC0,0x00    },
//    {0x00,0x00,0x08,0x00,0x00,0x14,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x34,0x00,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x04,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x00,0x34,0x14,0xC0,0x00    },
//    {0x00,0x00,0x08,0x00,0x04,0x14,0x00,0x00    },
//    {0x01,0x00,0x88,0x01,0x08,0x08,0x00,0x00    },
//    {0x00,0x00,0x08,0x10,0x32,0x00,0x00,0x00    },
//    {0x00,0x00,0x08,0x10,0x02,0x00,0x00,0x00    },
//    {0x02,0x00,0x08,0x10,0x32,0x00,0x00,0x00    },
//    {0x01,0x00,0x08,0x10,0x03,0x10,0x00,0x00    },
//    {0x01,0x00,0x08,0x10,0x02,0x20,0x01,0x00    },
//    {0x01,0x00,0x08,0x10,0x05,0x10,0x00,0x00    },
//    {0x01,0x00,0x08,0x10,0x04,0x08,0x04,0x00    },
//    {0x50,0x40,0x08,0x00,0x34,0x00,0x00,0x00    },
//    {0x50,0x40,0x08,0x00,0x04,0x00,0x00,0x00    },
//    {0x50,0x00,0x08,0x00,0x34,0x14,0xC0,0x00    },
//    {0x50,0x00,0x08,0x00,0x04,0x14,0x00,0x00    },
//    {0x02,0x00,0x00,0x00,0x30,0x14,0xC0,0x00    },
//    {0x02,0x00,0x00,0x00,0x00,0x14,0x00,0x00    },
//    {0x02,0x00,0x00,0x00,0x33,0x00,0x00,0x00    },
//    {0x02,0x00,0x00,0x00,0x03,0x14,0x00,0x00    },
//    {0x02,0x00,0x00,0x10,0x07,0x00,0x00,0x00    },
//    {0x02,0x00,0x00,0x10,0x31,0x00,0x00,0x00    },
//    {0x02,0x00,0x00,0x10,0x01,0x14,0x00,0x00    },
//    {0x00,0x00,0x00,0x00,0x03,0x14,0x00,0x00    },
//    {0x00,0x00,0x00,0x00,0x33,0x14,0xC0,0x00    },
//    {0x00,0x40,0x20,0x00,0x33,0x00,0x00,0x00    },
//    {0x60,0x43,0x20,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x43,0x20,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x42,0x20,0x10,0x03,0x10,0x18,0x00    },
//    {0x60,0x03,0x28,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x28,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x02,0x28,0x10,0x03,0x10,0x18,0x00    },
//    {0x00,0x00,0x28,0x10,0x03,0x20,0x02,0x00    },
//    {0x00,0x00,0x28,0x10,0x07,0x08,0x04,0x00    },
//    {0x00,0x03,0x28,0x00,0x0B,0x04,0x0B,0x00    },
//    {0x80,0x02,0x28,0x00,0x0B,0x04,0x10,0x00    },
//    {0x00,0x00,0x28,0x00,0x0B,0x00,0x00,0x00    },
//    {0x60,0x03,0x30,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x30,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x02,0x30,0x10,0x03,0x10,0x18,0x00    },
//    {0x00,0x00,0x30,0x10,0x03,0x20,0x02,0x00    },
//    {0x00,0x00,0x30,0x10,0x07,0x08,0x04,0x00    },
//    {0x00,0x03,0x30,0x00,0x0B,0x04,0x0B,0x00    },
//    {0x80,0x02,0x30,0x00,0x0B,0x04,0x10,0x00    },
//    {0x00,0x00,0x30,0x00,0x0B,0x00,0x00,0x00    },
//    {0x60,0x03,0x20,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x10,0x03,0x10,0x18,0x00    },
//    {0x00,0x00,0x20,0x10,0x03,0x20,0x02,0x00    },
//    {0x00,0x00,0x20,0x10,0x07,0x08,0x04,0x00    },
//    {0x00,0x03,0x20,0x00,0x0B,0x04,0x0B,0x00    },
//    {0x80,0x02,0x20,0x00,0x0B,0x04,0x10,0x00    },
//    {0x00,0x00,0x20,0x00,0x0B,0x00,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x03,0x10,0x0C,0x00    },
//    {0x00,0x00,0x28,0x00,0x03,0x10,0x0C,0x00    },
//    {0x00,0x00,0x30,0x00,0x03,0x10,0x0C,0x00    },
//    {0x60,0x43,0x08,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x43,0x08,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x42,0x08,0x10,0x03,0x10,0x18,0x00    },
//    {0x60,0x03,0x08,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x10,0x03,0x10,0x18,0x00    },
//    {0x00,0x00,0x08,0x10,0x03,0x20,0x02,0x00    },
//    {0x00,0x00,0x08,0x10,0x07,0x08,0x04,0x00    },
//    {0x00,0x03,0x08,0x00,0x0B,0x04,0x0B,0x00    },
//    {0x80,0x02,0x08,0x00,0x0B,0x04,0x10,0x00    },
//    {0x00,0x00,0x08,0x00,0x0B,0x00,0x00,0x00    },
//    {0x60,0x03,0x18,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x18,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x02,0x18,0x10,0x03,0x10,0x18,0x00    },
//    {0x00,0x00,0x18,0x10,0x03,0x20,0x02,0x00    },
//    {0x00,0x00,0x18,0x10,0x07,0x08,0x04,0x00    },
//    {0x00,0x03,0x18,0x00,0x0B,0x04,0x0B,0x00    },
//    {0x80,0x02,0x18,0x00,0x0B,0x04,0x10,0x00    },
//    {0x00,0x00,0x18,0x00,0x0B,0x00,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x03,0x10,0x0C,0x00    },
//    {0x00,0x00,0x18,0x00,0x03,0x10,0x0C,0x00    },
//    {0x50,0x43,0x10,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x42,0x10,0x10,0x03,0x10,0x18,0x00    },
//    {0x60,0x03,0x10,0x10,0x03,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x10,0x03,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x10,0x03,0x10,0x18,0x00    },
//    {0x00,0x00,0x10,0x10,0x03,0x20,0x02,0x00    },
//    {0x00,0x00,0x10,0x10,0x07,0x08,0x04,0x00    },
//    {0x00,0x03,0x10,0x00,0x0B,0x04,0x0B,0x00    },
//    {0x80,0x02,0x10,0x00,0x0B,0x04,0x10,0x00    },
//    {0x00,0x00,0x10,0x00,0x0B,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x03,0x10,0x0C,0x00    },
//    {0x60,0x43,0x10,0x10,0x03,0x10,0x0B,0x00    },
//    {0x60,0x43,0x10,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x43,0x10,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x42,0x10,0x10,0x02,0x10,0x18,0x00    },
//    {0x60,0x03,0x18,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x18,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x02,0x18,0x10,0x02,0x10,0x18,0x00    },
//    {0x00,0x00,0x18,0x10,0x02,0x20,0x02,0x00    },
//    {0x00,0x00,0x18,0x10,0x06,0x08,0x04,0x00    },
//    {0x00,0x03,0x18,0x00,0x0A,0x04,0x0B,0x00    },
//    {0x80,0x02,0x18,0x00,0x0A,0x04,0x10,0x00    },
//    {0x00,0x00,0x18,0x00,0x0A,0x00,0x00,0x00    },
//    {0x60,0x03,0x10,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x10,0x02,0x10,0x18,0x00    },
//    {0x00,0x00,0x10,0x10,0x02,0x20,0x02,0x00    },
//    {0x00,0x00,0x10,0x10,0x06,0x08,0x04,0x00    },
//    {0x00,0x03,0x10,0x00,0x0A,0x04,0x0B,0x00    },
//    {0x80,0x02,0x10,0x00,0x0A,0x04,0x10,0x00    },
//    {0x00,0x00,0x10,0x00,0x0A,0x00,0x00,0x00    },
//    {0x60,0x03,0x30,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x30,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x02,0x30,0x10,0x02,0x10,0x18,0x00    },
//    {0x00,0x00,0x30,0x10,0x02,0x20,0x02,0x00    },
//    {0x00,0x00,0x30,0x10,0x06,0x08,0x04,0x00    },
//    {0x00,0x03,0x30,0x00,0x0A,0x04,0x0B,0x00    },
//    {0x80,0x02,0x30,0x00,0x0A,0x04,0x10,0x00    },
//    {0x00,0x00,0x30,0x00,0x0A,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x02,0x10,0x0C,0x00    },
//    {0x00,0x00,0x18,0x00,0x02,0x10,0x0C,0x00    },
//    {0x00,0x00,0x30,0x00,0x02,0x10,0x0C,0x00    },
//    {0x60,0x43,0x20,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x43,0x20,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x42,0x20,0x10,0x02,0x10,0x18,0x00    },
//    {0x60,0x03,0x28,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x28,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x02,0x28,0x10,0x02,0x10,0x18,0x00    },
//    {0x00,0x00,0x28,0x10,0x02,0x20,0x02,0x00    },
//    {0x00,0x00,0x28,0x10,0x06,0x08,0x04,0x00    },
//    {0x00,0x03,0x28,0x00,0x0A,0x04,0x0B,0x00    },
//    {0x80,0x02,0x28,0x00,0x0A,0x04,0x10,0x00    },
//    {0x00,0x00,0x28,0x00,0x0A,0x00,0x00,0x00    },
//    {0x60,0x03,0x20,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x10,0x02,0x10,0x18,0x00    },
//    {0x00,0x00,0x20,0x10,0x02,0x20,0x02,0x00    },
//    {0x00,0x00,0x20,0x10,0x06,0x08,0x04,0x00    },
//    {0x00,0x03,0x20,0x00,0x0A,0x04,0x0B,0x00    },
//    {0x80,0x02,0x20,0x00,0x0A,0x04,0x10,0x00    },
//    {0x00,0x00,0x20,0x00,0x0A,0x00,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x02,0x10,0x0C,0x00    },
//    {0x00,0x00,0x28,0x00,0x02,0x10,0x0C,0x00    },
//    {0x00,0x40,0x08,0x00,0x02,0x10,0x0C,0x00    },
//    {0x60,0x43,0x08,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x43,0x08,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x42,0x08,0x10,0x02,0x10,0x18,0x00    },
//    {0x60,0x03,0x08,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x10,0x02,0x10,0x18,0x00    },
//    {0x00,0x00,0x08,0x10,0x02,0x20,0x02,0x00    },
//    {0x00,0x00,0x08,0x10,0x06,0x08,0x04,0x00    },
//    {0x00,0x03,0x08,0x00,0x0A,0x04,0x0B,0x00    },
//    {0x80,0x02,0x08,0x00,0x0A,0x04,0x10,0x00    },
//    {0x00,0x00,0x08,0x00,0x0A,0x00,0x00,0x00    },
//    {0x60,0x43,0x08,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x43,0x08,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x42,0x08,0x10,0x00,0x10,0x18,0x00    },
//    {0x60,0x03,0x08,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x10,0x00,0x10,0x18,0x00    },
//    {0x00,0x00,0x08,0x10,0x04,0x08,0x04,0x00    },
//    {0x00,0x03,0x08,0x00,0x08,0x04,0x0B,0x00    },
//    {0x80,0x02,0x08,0x00,0x08,0x04,0x10,0x00    },
//    {0x00,0x00,0x08,0x00,0x08,0x00,0x00,0x00    },
//    {0x60,0x03,0x18,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x03,0x18,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x18,0x10,0x00,0x10,0x18,0x00    },
//    {0x00,0x00,0x18,0x10,0x04,0x08,0x04,0x00    },
//    {0x00,0x03,0x18,0x00,0x08,0x04,0x0B,0x00    },
//    {0x80,0x02,0x18,0x00,0x08,0x04,0x10,0x00    },
//    {0x00,0x00,0x18,0x00,0x08,0x00,0x00,0x00    },
//    {0x60,0x03,0x28,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x03,0x28,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x28,0x10,0x00,0x10,0x18,0x00    },
//    {0x00,0x00,0x28,0x10,0x04,0x08,0x04,0x00    },
//    {0x00,0x03,0x28,0x00,0x08,0x04,0x0B,0x00    },
//    {0x80,0x02,0x28,0x00,0x08,0x04,0x10,0x00    },
//    {0x00,0x00,0x28,0x00,0x08,0x00,0x00,0x00    },
//    {0x00,0x40,0x08,0x00,0x00,0x10,0x0C,0x00    },
//    {0x00,0x00,0x18,0x00,0x00,0x10,0x0C,0x00    },
//    {0x00,0x00,0x28,0x00,0x00,0x10,0x0C,0x00    },
//    {0x60,0x43,0x10,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x43,0x10,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x42,0x10,0x10,0x00,0x10,0x18,0x00    },
//    {0x60,0x03,0x10,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x10,0x00,0x10,0x18,0x00    },
//    {0x00,0x00,0x10,0x10,0x04,0x08,0x04,0x00    },
//    {0x00,0x03,0x10,0x00,0x08,0x04,0x0B,0x00    },
//    {0x80,0x02,0x10,0x00,0x08,0x04,0x10,0x00    },
//    {0x00,0x00,0x10,0x00,0x08,0x00,0x00,0x00    },
//    {0x60,0x03,0x30,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x03,0x30,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x30,0x10,0x00,0x10,0x18,0x00    },
//    {0x00,0x00,0x30,0x10,0x04,0x08,0x04,0x00    },
//    {0x00,0x03,0x30,0x00,0x08,0x04,0x0B,0x00    },
//    {0x80,0x02,0x30,0x00,0x08,0x04,0x10,0x00    },
//    {0x00,0x00,0x30,0x00,0x08,0x00,0x00,0x00    },
//    {0x00,0x40,0x10,0x00,0x00,0x10,0x0C,0x00    },
//    {0x00,0x00,0x30,0x00,0x00,0x10,0x0C,0x00    },
//    {0x60,0x43,0x20,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x43,0x20,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x42,0x20,0x10,0x00,0x10,0x18,0x00    },
//    {0x60,0x03,0x20,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x10,0x00,0x10,0x18,0x00    },
//    {0x00,0x00,0x20,0x10,0x04,0x08,0x04,0x00    },
//    {0x00,0x03,0x20,0x00,0x08,0x04,0x0B,0x00    },
//    {0x80,0x02,0x20,0x00,0x08,0x04,0x10,0x00    },
//    {0x00,0x00,0x20,0x00,0x08,0x00,0x00,0x00    },
//    {0x00,0x40,0x20,0x00,0x00,0x10,0x0C,0x00    },
//    {0x00,0x00,0x00,0x10,0x02,0x14,0x00,0x00    },
//    {0x00,0x00,0x00,0x10,0x32,0x14,0xC0,0x00    },
//    {0x60,0x43,0x00,0x10,0x02,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x10,0x02,0x10,0x0B,0x00    },
//    {0x88,0x42,0x00,0x10,0x02,0x10,0x18,0x00    },
//    {0x10,0x03,0x08,0x10,0x02,0x10,0x0B,0x00    },
//    {0x10,0x03,0x10,0x10,0x02,0x10,0x0B,0x00    },
//    {0x10,0x03,0x20,0x10,0x02,0x10,0x0B,0x00    },
//    {0x00,0x00,0x00,0x10,0x04,0x14,0x00,0x00    },
//    {0x00,0x00,0x00,0x10,0x34,0x14,0xC0,0x00    },
//    {0x60,0x43,0x00,0x10,0x04,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x42,0x00,0x10,0x04,0x10,0x18,0x00    },
//    {0x60,0x03,0x08,0x10,0x04,0x10,0x0B,0x00    },
//    {0x10,0x03,0x08,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x10,0x04,0x10,0x18,0x00    },
//    {0x60,0x03,0x10,0x10,0x04,0x10,0x0B,0x00    },
//    {0x10,0x03,0x10,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x10,0x04,0x10,0x18,0x00    },
//    {0x60,0x03,0x20,0x10,0x04,0x10,0x0B,0x00    },
//    {0x10,0x03,0x20,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x10,0x04,0x10,0x18,0x00    },
//    {0x00,0x00,0x00,0x10,0x04,0x00,0x00,0x00    },
//    {0x60,0x43,0x20,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x43,0x20,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x42,0x20,0x10,0x05,0x10,0x18,0x00    },
//    {0x60,0x03,0x28,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x28,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x28,0x10,0x05,0x10,0x18,0x00    },
//    {0x00,0x00,0x28,0x10,0x07,0x20,0x02,0x00    },
//    {0x00,0x00,0x28,0x10,0x05,0x08,0x04,0x00    },
//    {0x00,0x03,0x28,0x00,0x0D,0x04,0x03,0x00    },
//    {0x80,0x02,0x28,0x00,0x0D,0x04,0x10,0x00    },
//    {0x00,0x00,0x28,0x00,0x0D,0x00,0x00,0x00    },
//    {0x60,0x03,0x30,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x30,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x30,0x10,0x05,0x10,0x18,0x00    },
//    {0x00,0x00,0x30,0x10,0x07,0x20,0x02,0x00    },
//    {0x00,0x00,0x30,0x10,0x05,0x08,0x04,0x00    },
//    {0x00,0x03,0x30,0x00,0x0D,0x04,0x03,0x00    },
//    {0x80,0x02,0x30,0x00,0x0D,0x04,0x10,0x00    },
//    {0x00,0x00,0x30,0x00,0x0D,0x00,0x00,0x00    },
//    {0x60,0x03,0x20,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x20,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x20,0x10,0x05,0x10,0x18,0x00    },
//    {0x00,0x00,0x20,0x10,0x07,0x20,0x02,0x00    },
//    {0x00,0x00,0x20,0x10,0x05,0x08,0x04,0x00    },
//    {0x00,0x03,0x20,0x00,0x0D,0x04,0x03,0x00    },
//    {0x80,0x02,0x20,0x00,0x0D,0x04,0x10,0x00    },
//    {0x00,0x00,0x20,0x00,0x0D,0x00,0x00,0x00    },
//    {0x60,0x43,0x08,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x43,0x08,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x42,0x08,0x10,0x05,0x10,0x18,0x00    },
//    {0x60,0x03,0x08,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x08,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x08,0x10,0x05,0x10,0x18,0x00    },
//    {0x00,0x00,0x08,0x10,0x07,0x20,0x02,0x00    },
//    {0x00,0x00,0x08,0x10,0x05,0x08,0x04,0x00    },
//    {0x00,0x03,0x08,0x00,0x0D,0x04,0x03,0x00    },
//    {0x80,0x02,0x08,0x00,0x0D,0x04,0x10,0x00    },
//    {0x00,0x00,0x08,0x00,0x0D,0x00,0x00,0x00    },
//    {0x60,0x03,0x18,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x18,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x18,0x10,0x05,0x10,0x18,0x00    },
//    {0x00,0x00,0x18,0x10,0x07,0x20,0x02,0x00    },
//    {0x00,0x00,0x18,0x10,0x05,0x08,0x04,0x00    },
//    {0x00,0x03,0x18,0x00,0x0D,0x04,0x03,0x00    },
//    {0x80,0x02,0x18,0x00,0x0D,0x04,0x10,0x00    },
//    {0x00,0x00,0x18,0x00,0x0D,0x00,0x00,0x00    },
//    {0x60,0x03,0x10,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x03,0x10,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x02,0x10,0x10,0x05,0x10,0x18,0x00    },
//    {0x00,0x00,0x10,0x10,0x07,0x20,0x02,0x00    },
//    {0x00,0x00,0x10,0x10,0x05,0x08,0x04,0x00    },
//    {0x00,0x03,0x10,0x00,0x0D,0x04,0x03,0x00    },
//    {0x80,0x02,0x10,0x00,0x0D,0x04,0x10,0x00    },
//    {0x00,0x00,0x10,0x00,0x0D,0x00,0x00,0x00    },
//    {0x60,0x43,0x10,0x10,0x05,0x10,0x0B,0x00    },
//    {0x50,0x43,0x10,0x10,0x05,0x10,0x0B,0x00    },
//    {0x88,0x42,0x10,0x10,0x05,0x10,0x18,0x00    },
//    {0x00,0x00,0x08,0x00,0x34,0x00,0x00,0x00    },
//    {0x60,0x43,0x10,0x10,0x04,0x10,0x0B,0x00    },
//    {0x50,0x43,0x10,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x42,0x10,0x10,0x04,0x10,0x18,0x00    },
//    {0x60,0x03,0x18,0x10,0x04,0x10,0x0B,0x00    },
//    {0x50,0x03,0x18,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x18,0x10,0x04,0x10,0x18,0x00    },
//    {0x00,0x00,0x18,0x10,0x06,0x20,0x02,0x00    },
//    {0x00,0x03,0x18,0x00,0x0C,0x04,0x03,0x00    },
//    {0x80,0x02,0x18,0x00,0x0C,0x04,0x10,0x00    },
//    {0x00,0x00,0x18,0x00,0x0C,0x00,0x00,0x00    },
//    {0x50,0x03,0x10,0x10,0x04,0x10,0x0B,0x00    },
//    {0x00,0x00,0x10,0x10,0x06,0x20,0x02,0x00    },
//    {0x00,0x03,0x10,0x00,0x0C,0x04,0x03,0x00    },
//    {0x80,0x02,0x10,0x00,0x0C,0x04,0x10,0x00    },
//    {0x00,0x00,0x10,0x00,0x0C,0x00,0x00,0x00    },
//    {0x60,0x03,0x30,0x10,0x04,0x10,0x0B,0x00    },
//    {0x50,0x03,0x30,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x30,0x10,0x04,0x10,0x18,0x00    },
//    {0x00,0x00,0x30,0x10,0x06,0x20,0x02,0x00    },
//    {0x00,0x03,0x30,0x00,0x0C,0x04,0x03,0x00    },
//    {0x80,0x02,0x30,0x00,0x0C,0x04,0x10,0x00    },
//    {0x00,0x00,0x30,0x00,0x0C,0x00,0x00,0x00    },
//    {0x60,0x03,0x28,0x10,0x04,0x10,0x0B,0x00    },
//    {0x50,0x03,0x28,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x02,0x28,0x10,0x04,0x10,0x18,0x00    },
//    {0x60,0x43,0x08,0x10,0x04,0x10,0x0B,0x00    },
//    {0x50,0x43,0x08,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x42,0x08,0x10,0x04,0x10,0x18,0x00    },
//    {0x50,0x03,0x08,0x10,0x04,0x10,0x0B,0x00    },
//    {0x00,0x00,0x08,0x10,0x06,0x20,0x02,0x00    },
//    {0x00,0x03,0x08,0x00,0x0C,0x04,0x03,0x00    },
//    {0x80,0x02,0x08,0x00,0x0C,0x04,0x10,0x00    },
//    {0x00,0x00,0x08,0x00,0x0C,0x00,0x00,0x00    },
//    {0x00,0x00,0x28,0x10,0x06,0x20,0x02,0x00    },
//    {0x00,0x03,0x28,0x00,0x0C,0x04,0x03,0x00    },
//    {0x80,0x02,0x28,0x00,0x0C,0x04,0x10,0x00    },
//    {0x00,0x00,0x28,0x00,0x0C,0x00,0x00,0x00    },
//    {0x60,0x43,0x20,0x10,0x04,0x10,0x0B,0x00    },
//    {0x50,0x43,0x20,0x10,0x04,0x10,0x0B,0x00    },
//    {0x88,0x42,0x20,0x10,0x04,0x10,0x18,0x00    },
//    {0x50,0x03,0x20,0x10,0x04,0x10,0x0B,0x00    },
//    {0x00,0x00,0x20,0x10,0x06,0x20,0x02,0x00    },
//    {0x00,0x03,0x20,0x00,0x0C,0x04,0x03,0x00    },
//    {0x80,0x02,0x20,0x00,0x0C,0x04,0x10,0x00    },
//    {0x00,0x00,0x20,0x00,0x0C,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x00,0x08,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x00,0x38,0x00,0x00,0x00    },
//    {0x00,0x40,0x00,0x00,0x08,0x14,0x00,0x00    },
//    {0x00,0x40,0x00,0x00,0x38,0x14,0xC0,0x00    },
//    {0x60,0x43,0x00,0x10,0x00,0x10,0x0B,0x00    },
//    {0x50,0x43,0x00,0x10,0x00,0x10,0x0B,0x00    },
//    {0x88,0x42,0x00,0x10,0x00,0x10,0x18,0x00    },
//};
//extern U8 debug_err_buf[129];
//extern U8 debug_err_count;

//-------------------------------常量定义-------------------------------------

//-------------------------------需量使用----------------------------
//--------需量ID2标识码---------------------
static const U8 demand_id2[30] =
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
    0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,
    0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46
};
/*
#define SINGLE_DMD_MAX      30
static const U8 single_dmd_id2[SINGLE_DMD_MAX] =
{
    0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e,//A相
    0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,//B相
    0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 //C相
};
*/
//--------当前需量存储地址,对应ID2标识码表-------------------
static const U32 current_demand_addr[30] =
{

    DMD_POSP_01010000_00_ADDR,                  //正向有功需量
    DMD_NEGP_01020000_00_ADDR,                  //反向有功需量
    DMD_COMQ1_01030000_00_ADDR,                 //组合1无功需量
    DMD_COMQ2_01040000_00_ADDR,                 //组合2无功需量
    DMD_REQ1Q_01050000_00_ADDR,                 //象限1无功需量
    DMD_REQ2Q_01060000_00_ADDR,                 //象限2无功需量
    DMD_REQ3Q_01070000_00_ADDR,                 //象限3无功需量
    DMD_REQ4Q_01080000_00_ADDR,                 //象限4无功需量
    DMD_POSS_01090000_00_ADDR,                  //正向视在需量
    DMD_NEGS_010A0000_00_ADDR,                  //反向视在需量

    DMD_APOSP_01150000_00_ADDR,                 //A相
    DMD_ANEGP_01160000_00_ADDR,
    DMD_ACOMQ1_01170000_00_ADDR,
    DMD_ACOMQ2_01180000_00_ADDR,
    DMD_AREQ1Q_01190000_00_ADDR,
    DMD_AREQ2Q_011A0000_00_ADDR,
    DMD_AREQ3Q_011B0000_00_ADDR,
    DMD_AREQ4Q_011C0000_00_ADDR,
    DMD_APOSS_011D0000_00_ADDR,
    DMD_ANEGS_011E0000_00_ADDR,

    DMD_CPOSP_013D0000_00_ADDR,                 //C相
    DMD_CNEGP_013E0000_00_ADDR,
    DMD_CCOMQ1_013F0000_00_ADDR,
    DMD_CCOMQ2_01400000_00_ADDR,
    DMD_CREQ1Q_01410000_00_ADDR,
    DMD_CREQ2Q_01420000_00_ADDR,
    DMD_CREQ3Q_01430000_00_ADDR,
    DMD_CREQ4Q_01440000_00_ADDR,
    DMD_CPOSS_01450000_00_ADDR,
    DMD_CNEGS_01460000_00_ADDR
};
//-------结算日需量存储地址,对应ID2标识码表--------------
static const U32 account_demand_addr[30]=
{
    ACCOUNT_DAY_DEMAND_ADDR,                                //正向有功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN,       //反向有功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 2,   //组合1无功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 3,   //组合2无功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 4,   //象限1无功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 5,   //象限2无功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 6,   //象限3无功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 7,   //象限4无功需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 8,   //正向视在需量
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 9,   //反向视在需量

    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10,                      //A相
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 2,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 3,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 4,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 5,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 6,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 7,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 8,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 9,

    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 10,    //C相
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 11,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 12,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 13,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 14,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 15,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 16,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 17,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 18,
    ACCOUNT_DAY_DEMAND_ADDR + TOTAL_PHASE_DEMAND_LEN * 10 + DEMAND_LEN * 19,
};

//-----------------------------电能量使用------------------------------------
//---------电能量ID2标识码--------------------
static const U8 energy_id2[46] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x80, 0x81, 0x82, 0x83, 0x84, 0x15, 0x16, 0x17, 0x18,
    0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45,
    0x46, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
};
/*
#define SINGLE_ENG_MAX      51
static const U8 single_engy_id2[SINGLE_ENG_MAX] =
{
    0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, //A相
    0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAF, //B相
    0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xC1, 0xC2, //C相
};*/
//--------当前电能量存储地址对应ID2标识表--
static const U32 current_energy_addr[46] =
{
    ENG_COMPOSP_00000000_00_ADDR,                   //组合有功     11个
    ENG_POSP_00010000_00_ADDR,                      //正向有功电能量
    ENG_NEGP_00020000_00_ADDR,                      //反向有功电能量
    ENG_COMQ1_00030000_00_ADDR,                     //组合1无功电能量
    ENG_COMQ2_00040000_00_ADDR,                     //组合2无功电能量
    ENG_REA1Q_00050000_00_ADDR,                     //象限1无功电能量
    ENG_REA2Q_00060000_00_ADDR,                     //象限2无功电能量
    ENG_REA3Q_00070000_00_ADDR,                     //象限3无功电能量
    ENG_REA4Q_00080000_00_ADDR,                     //象限4无功电能量
    ENG_POSS_00090000_00_ADDR,                      //正向视在电能量
    ENG_NEGS_000A0000_00_ADDR,                      //反向视在电能量


    ENG_RELATOTP_00800000_00_ADDR,                  //关联电能量  5个
    ENG_RELAPOSBP_00810000_00_ADDR,                 //正向基波有功电能量
    ENG_RELANEGBP_00820000_00_ADDR,                 //反向基波有功电能量
    ENG_RELAPOSHP_00830000_00_ADDR,                 //正向谐波有功电能量
    ENG_RELANEGHP_00840000_00_ADDR,                 //反向谐波有功电能量

    ENG_APOSP_00150000_00_ADDR,                     //A相 10个
    ENG_ANEGP_00160000_00_ADDR,
    ENG_ACOMQ1_00170000_00_ADDR,
    ENG_ACOMQ2_00180000_00_ADDR,
    ENG_AREA1Q_00190000_00_ADDR,
    ENG_AREA2Q_001A0000_00_ADDR,
    ENG_AREA3Q_001B0000_00_ADDR,
    ENG_AREA4Q_001C0000_00_ADDR,
    ENG_APOSS_001D0000_00_ADDR,
    ENG_ANEGS_001E0000_00_ADDR,

    ENG_ARELATOTP_00940000_00_ADDR,                 //A相关联 5个
    ENG_ARELAPOSBP_00950000_00_ADDR,
    ENG_ARELANEGBP_00960000_00_ADDR,
    ENG_ARELAPOSHP_00970000_00_ADDR,
    ENG_ARELANEGHP_00980000_00_ADDR,

    ENG_CPOSP_003D0000_00_ADDR,                     //C相 10个
    ENG_CNEGP_003E0000_00_ADDR,
    ENG_CCOMQ1_003F0000_00_ADDR,
    ENG_CCOMQ2_00400000_00_ADDR,
    ENG_CREA1Q_00410000_00_ADDR,
    ENG_CREA2Q_00420000_00_ADDR,
    ENG_CREA3Q_00430000_00_ADDR,
    ENG_CREA4Q_00440000_00_ADDR,
    ENG_CPOSS_00450000_00_ADDR,
    ENG_CNEGS_00460000_00_ADDR,

    ENG_CRELATOTP_00BC0000_00_ADDR,                 //C相关联5个
    ENG_CRELAPOSBP_00BD0000_00_ADDR,
    ENG_CRELANEGBP_00BE0000_00_ADDR,
    ENG_CRELAPOSHP_00BF0000_00_ADDR,
    ENG_CRELANEGHP_00C00000_00_ADDR
};
//--------结算日电能量存储地址对应ID2标识表--
static const U32 account_energy_addr[46] =
{
    ACCOUNT_DAY_ENERGY_ADDR,                                        //组合有功     11个
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 1,   //正向有功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 2,   //反向有功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 3,   //组合1无功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 4,   //组合2无功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 5,   //象限1无功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 6,   //象限2无功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 7,   //象限3无功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 8,   //象限4无功电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 9,   //正向视在电能量
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 10,  //反向视在电能量


    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11,                      //关联总电能 5个
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 1,     //正向有功基波总电能
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 2,     //反向有功基波总电能
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 3,     //正向有功谐波总电能
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 4,     //反向有功谐波总电能

    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 5,     //A相
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 6,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 7,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 8,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 9,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 10,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 11,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 12,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 13,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 14,

    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 15,    //A相关联
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 16,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 17,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 18,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 19,

    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 20,    //C相
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 21,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 22,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 23,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 24,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 25,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 26,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 27,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 28,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 29,

    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 30,    //C相关联
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 31,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 32,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 33,
    ACCOUNT_DAY_ENERGY_ADDR + ACCOUNT_TOTAL_PHASE_ENERGY_LEN * 11 + DEMAND_LEN * 34
};

//-----------------------------------瞬时变量使用---------------------------------
//------对应DI2&DI1标识码表，[0:3]对应DI1取值，[4]为DI1取FF时总项数，[5]每项的字节长度
//即static const U32 variable_frm[ID2-1][DI1]所确定的某变
//量在内存的地址,无合相数据如电压，该地址填0xFFFFFFFF:无效
static const U32 variable_frm[7][6] =
{
    {0xFFFFFFFF,VAR_AVOLT_02010100_00_ADDR,VAR_BVOLT_02010200_00_ADDR,VAR_CVOLT_02010300_00_ADDR,3,2},              //电压{无效,A,B,C}
    {0xFFFFFFFF,VAR_ACURRENT_02020100_00_ADDR,VAR_BCURRENT_02020200_00_ADDR,VAR_CCURRENT_02020300_00_ADDR,3,3},     //电流{无效,A,B,C}
    {VAR_TOTPPOW_02030000_00_ADDR,VAR_APPOW_02030100_00_ADDR,VAR_BPPOW_02030200_00_ADDR,VAR_CPPOW_02030300_00_ADDR,4,3},//有功功率{TOT,A,B,C}
    {VAR_TOTQPOW_02040000_00_ADDR,VAR_AQPOW_02040100_00_ADDR,VAR_BQPOW_02040200_00_ADDR,VAR_CQPOW_02040300_00_ADDR,4,3},//无功功率{TOT,A,B,C}
    {VAR_TOTSPOW_02050000_00_ADDR,VAR_ASPOW_02050100_00_ADDR,VAR_BSPOW_02050200_00_ADDR,VAR_CSPOW_02050300_00_ADDR,4,3},//视在功率{TOT,A,B,C}
    {VAR_TOTFACT_02060000_00_ADDR,VAR_AFACT_02060100_00_ADDR,VAR_BFACT_02060200_00_ADDR,VAR_CFACT_02060300_00_ADDR,4,2},//功率因数{TOT,A,B,C}
    {0xFFFFFFFF,VAR_AANGL_02070100_00_ADDR,VAR_BANGL_02070200_00_ADDR,VAR_CANGL_02070300_00_ADDR,3,2},              //相角{无效,A,B,C}
};

//----------------------------------参变量读写使用--------------------------------------
//------[0]低24位对应标识码ID0,ID1,ID2,高8位表示字节长度、[1]标识码对应的存储地址。
#define PAR_FRM_NUM 10//62
static const U32 parameter_frm[PAR_FRM_NUM][2] =
{
//    {0x01000103, PAR_DMDMAXP_04000103_00_ADDR}, //最大需量周期（分钟）  0
//    {0x01000104, PAR_SLIDTIME_04000104_00_ADDR},//滑差时间（分钟）      1
//    {0x05000106, PAR_TZSWTIME_04000106_00_ADDR},//两套时区表切换时间（年月日时分）  2
//    {0x05000107, PAR_TSSWTIME_04000107_00_ADDR},//两套日时段表切换时间（年月日时分）3
//
//    {0x01000201, PAR_TZAMOUNT_04000201_00_ADDR},//年时区数p≤14                 4
//    {0x01000202, PAR_TSAMOUNT_04000202_00_ADDR},//日时段表数q≤8                5
//    {0x01000203, PAR_TSSWCNT_04000203_00_ADDR}, //日时段数(每日切换数) m≤14    6
//    {0x01000204, PAR_FEERATE_04000204_00_ADDR}, //费率数k≤63                   7
//    {0x02000205, PAR_HOLIDYS_04000205_00_ADDR}, //公共假日数n≤254              8

    {0x06000401, PAR_HVMADDR_04000401_00_ADDR}, //通信地址                      9
    {0x06000402, PAR_HVMNUM_04000402_00_ADDR},  //表号                          10
    {0x20000403, PAR_PROPTNUM_04000403_00_ADDR},//资产管理编码(ASCII)           11
//
//    {0x01000801, PAR_RESTDAY_04000801_00_ADDR}, //周休日状态字                  12
//    {0x01000802, PAR_RESTDAYTS_04000802_00_ADDR},//周休日执行时段表号            13
//    {0x01000601, PAR_PCOMB_04000601_00_ADDR},   //有功组合方式特征字            14
//    {0x01000602, PAR_QCOMB1_04000602_00_ADDR},  //无功组合方式1特征字           15
//    {0x01000603, PAR_QCOMB2_04000603_00_ADDR},  //无功组合方式2特征字           16

//    {0x01000901, PAR_LOADRCDMD_04000901_00_ADDR},//负荷记录模式字                17
//    {0x01000902, PAR_FREEZEMD_04000902_00_ADDR},//冻结数据模式字                18
//    {0x04000a01, PAR_LOADRCDST_04000A01_00_ADDR},//负荷记录起始时间（月日时分）  19
//    {0x02000a02, PAR_LOAD1INTV_04000A02_00_ADDR},//第1类负荷记录间隔时间（分钟） 20
//    {0x02000a03, PAR_LOAD2INTV_04000A03_00_ADDR},//第2类负荷记录间隔时间（分钟） 21
//    {0x02000a04, PAR_LOAD3INTV_04000A04_00_ADDR},//第3类负荷记录间隔时间（分钟） 22
//    {0x02000a05, PAR_LOAD4INTV_04000A05_00_ADDR},//第4类负荷记录间隔时间（分钟） 23
//    {0x02000a06, PAR_LOAD5INTV_04000A06_00_ADDR},//第5类负荷记录间隔时间（分钟） 24
//    {0x02000a07, PAR_LOAD6INTV_04000A07_00_ADDR},//第6类负荷记录间隔时间（分钟） 25
//
//    {0x02000b01, PAR_FIRACCNT_04000B01_00_ADDR},//每月第1结算日（日+时）        26
//    {0x02000b02, PAR_SECACCNT_04000B02_00_ADDR},//每月第2结算日（日+时）        27
//    {0x02000b03, PAR_THIACCNT_04000B03_00_ADDR},//每月第3结算日（日+时）        28
//
//    {0x03000e01, PAR_POSPTOP_04000E01_00_ADDR}, //正向有功功率上限              29
//    {0x03000e02, PAR_POSPTOP_04000E01_00_ADDR}, //反向有功功率上限              30
//    {0x02000e03, PAR_VTOP_04000E03_00_ADDR},    //电压上限值                    31
//    {0x02000e04, PAR_VBOTTOM_04000E04_00_ADDR}, //电压下限值                    32

    {0x03000102, HARDWARE_RTC_ADDR},            //时间                          33
    {0x04000101, HARDWARE_RTC_ADDR + 3},        //日期和星期                    34
//    {0x02000105, PAR_PLSWIDTH_04000105_00_ADDR},        //校表脉冲宽度（毫秒）          35
//
//    {0x06000404, PAR_VRATING_04000404_00_ADDR},         //额定电压(ASCII 码)            36
//    {0x06000405, PAR_IRATING_04000405_00_ADDR},         //额定电流/基本电流(ASCII 码)   37
//    {0x06000406, PAR_IMAX_04000406_00_ADDR},            //最大电流(ASCII 码)            38
//    {0x04000407, PAR_PACCURACY_04000407_00_ADDR},       //有功准确度等级(ASCII 码)      39
//    {0x04000408, PAR_QACCURACY_04000408_00_ADDR},       //无功准确度等级(ASCII 码)      40
//    {0x03000409, PAR_PCONSTANT_04000409_00_ADDR},       //电表有功常数                  41
//    {0x0300040A, PAR_QCONSTANT_0400040A_00_ADDR},       //电表无功常数                  42
//    {0x0A00040B, PAR_HVMTYPE_0400040B_00_ADDR},         //电表型号(ASCII 码)            43
//    {0x0A00040C, PAR_HVMTYPE_0400040B_TOT_LEN},         //生产日期(ASCII 码)            44
//    {0x1000040D, PAR_PROTOVER_0400040D_00_ADDR},        //协议版本号(ASCII 码)          45
//    {0x20800001, PAR_SWVER_04800001_00_ADDR},           //厂家软件版本号(ASCII 码)      46
//    {0x20800002, PAR_HWVER_04800002_00_ADDR},           //厂家硬件版本号(ASCII 码)      47
//    {0x20800003, PAR_MFTNUM_04800003_00_ADDR},          //厂家编号(ASCII 码)            48
//
//    {0, 0},                                             //49(保留)
//    {0, 0},                                             //50(保留)
//    {0, 0},                                             //51(保留)

//    {0x20000701, PAR_MDIRDABD_04000701_00_ADDR},        //调制型红外光口通信速率特征字  52
//    {0x01000702, PAR_CTIRDABD_04000702_00_ADDR},        //接触式红外光口通信速率特征字  53
//    {0x01000703, PAR_PORT1BD_04000703_00_ADDR},         //通信口 1 通信速率特征字       54
//    {0x01000704, PAR_PORT2BD_04000704_00_ADDR},         //通信口 2 通信速率特征字       55
//    {0x01000705, PAR_PORT3BD_04000705_00_ADDR},         //通信口 3 通信速率特征字       56
    {0x01000301, PAR_LPDISCNT_04000301_00_ADDR},        //自动循环显示屏数              57
    {0x01000302, PAR_DISTIME_04000302_00_ADDR},         //每屏显示时间                  58
    {0x01000303, PAR_ENGDECIM_04000303_00_ADDR},        //显示电能小数位数              59
    {0x01000304, PAR_DMDDECIM_04000304_00_ADDR},        //显示功率(最大需量)小数位数    60
    {0x01000305, PAR_KEYDIS_04000305_00_ADDR},          //按键循环显示屏数              61
};
//------------参数设置密码权限对应表，10到1对应0到9级权限，如6对应4级密码，11是超级密码，12是超级跳线
static const U8 password_popedom[52 + 10] =
{
    6,                                                  //最大需量周期（分钟）  0
    6,                                                  //滑差时间（分钟）      1
    6,                                                  //两套时区表切换时间（年月日时分）  2
    6,                                                  //两套日时段表切换时间（年月日时分）3
    6,                                                  //年时区数p≤14                 4
    6,                                                  //日时段表数q≤8                5
    6,                                                  //日时段数(每日切换数) m≤14    6
    6,                                                  //费率数k≤63                   7
    6,                                                  //公共假日数n≤254              8
    6,                                                  //通信地址                      9
    6,                                                  //表号                          10
    6,                                                  //资产管理编码(ASCII)           11
    6,                                                  //周休日状态字                  12
    6,                                                  //周休日执行时段表号            13
    6,                                                  //有功组合方式特征字            14
    6,                                                  //无功组合方式1特征字           15
    6,                                                  //无功组合方式2特征字           16
    6,                                                  //负荷记录模式字                17
    6,                                                  //冻结数据模式字                18
    6,                                                  //负荷记录起始时间（月日时分）  19
    6,                                                  //第1类负荷记录间隔时间（分钟） 20
    6,                                                  //第2类负荷记录间隔时间（分钟） 21
    6,                                                  //第3类负荷记录间隔时间（分钟） 22
    6,                                                  //第4类负荷记录间隔时间（分钟） 23
    6,                                                  //第5类负荷记录间隔时间（分钟） 24
    6,                                                  //第6类负荷记录间隔时间（分钟） 25
    6,                                                  //每月第1结算日（日+时）        26
    6,                                                  //每月第2结算日（日+时）        27
    6,                                                  //每月第3结算日（日+时）        28
    6,                                                  //正向有功功率上限              29
    6,                                                  //反向有功功率上限              30
    6,                                                  //电压上限值                    31
    6,                                                  //电压下限值                    32
    6,                                                  //时间                          33
    6,                                                  //日期和星期                    34
    6,                                                  //校表脉冲宽度（毫秒）          35
    11,                                                 //额定电压(ASCII 码)            36
    11,                                                 //额定电流/基本电流(ASCII 码)   37
    11,                                                 //最大电流(ASCII 码)            38
    11,                                                 //有功准确度等级(ASCII 码)      39
    11,                                                 //无功准确度等级(ASCII 码)      40
    11,                                                 //电表有功常数                  41
    11,                                                 //电表无功常数                  42
    11,                                                 //电表型号(ASCII 码)            43
    11,                                                 //生产日期(ASCII 码)            44
    11,                                                 //协议版本号(ASCII 码)          45
    11,                                                 //厂家软件版本号(ASCII 码)      46
    11,                                                 //厂家硬件版本号(ASCII 码)      47
    11,                                                 //厂家编号(ASCII 码)            48

    6,                                                  //第一套时区表                  49
    6,                                                  //第二套时区表                  50
    6,                                                  //公共假日                      51

    6,                                                  //调制型红外光口通信速率特征字  52
    6,                                                  //接触式红外光口通信速率特征字  53
    6,                                                  //通信口 1 通信速率特征字       54
    6,                                                  //通信口 2 通信速率特征字       55
    6,                                                  //通信口 3 通信速率特征字       56
    6,                                                  //自动循环显示屏数              57
    6,                                                  //每屏显示时间                  58
    6,                                                  //显示电能小数位数              59
    6,                                                  //显示功率(最大需量)小数位数    60
    6                                                   //按键循环显示屏数              61
};
//------[0]低16位对应标识码ID1,ID2,高8位表示最高项数，中8位表示单条标识的字节数
//------说明：[1]标识码对应的存储地址均为ID0=0时的地址，因为假日起始为1,所以减4
static const U32 time_table_frm[3][2] =
{
    0x082A0100, PAR_T1TZ1SDTS_04010000_00_ADDR,         //第一套时区表
    0x082A0200, PAR_T2TZDAT_04020000_00_ADDR,           //第二套时区表
    0xFE040300, PAR_HOLIDYFN_04030001_00_ADDR - 4       //公共假日,对应的地址为第一个假日的地址- 4,
};
//-------------------------------冻结数据使用-------------------------------------------------
static const U32 freeze_type_addr[4] =
{
    TIMING_FREEZE_DATA_ADDR,                            //[0] 定时冻结数据起地址
    INSTANT_FREEZE_DATA_ADDR,                           //[1] 瞬时冻结数据起地址
    ZONE_CHANGE_FREEZE_DATA_ADDR,                       //[2] 时区切换冻结数据起地址
    TIME_CHANGE_FREEZE_DATA_ADDR                        //[3] 时段切换冻结数据起地址
};
//------ID2对应的地址偏移和长度，[0]偏移地址、[1]长度，跟下冻结状态字表对应
static const U8 freeze_offset_addr[12][2] =
{
    0, 5,                                                                               //冻结时间
    5, (RATE_NUM + 1) * ENERGY_LEN,                                                     //正向有功电能
    5 + (RATE_NUM + 1) * ENERGY_LEN, (RATE_NUM + 1) * ENERGY_LEN,                       //反向有功电能
    5 + 2 * (RATE_NUM + 1) * ENERGY_LEN, (RATE_NUM + 1) * ENERGY_LEN,                   //组合无功电能1
    5 + 3 * (RATE_NUM + 1) * ENERGY_LEN, (RATE_NUM + 1) * ENERGY_LEN,                   //组合无功电能2
    5 + 4 * (RATE_NUM + 1) * ENERGY_LEN, (RATE_NUM + 1) * ENERGY_LEN,                   //第一象限无功电能
    5 + 5 * (RATE_NUM + 1) * ENERGY_LEN, (RATE_NUM + 1) * ENERGY_LEN,                   //第二象限无功电能
    5 + 6 * (RATE_NUM + 1) * ENERGY_LEN, (RATE_NUM + 1) * ENERGY_LEN,                   //第三象限无功电能
    5 + 7 * (RATE_NUM + 1) * ENERGY_LEN, (RATE_NUM + 1) * ENERGY_LEN,                   //第四象限无功电能
    5 + 8 * (RATE_NUM + 1) * ENERGY_LEN, TOTAL_PHASE_DEMAND_LEN,                        //有功需量
    5 + 8 * (RATE_NUM + 1) * ENERGY_LEN + TOTAL_PHASE_DEMAND_LEN,TOTAL_PHASE_DEMAND_LEN,//无功需量
    5 + 8 * (RATE_NUM + 1) * ENERGY_LEN + 2 * TOTAL_PHASE_DEMAND_LEN,3 * 8,             //变量

};
//----------------冻结状态字对应位，跟上表对应---------------
static const U8 freeze_state_table[12] =
{
    0, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10,0x10, 0x10, 0x20, 0x40, 0x80
};

//------------------------------------事件记录使用---------------------------------------------
//----[0]说明：高12位为单条记录的长度，低16位为ID1和ID2标识码，中间的4位bit16到19为总次数的长度
//----[1]说明：标识码对应的记录起始地址，每项10条，采用循环存储。
// static const U32 event_recond_addr[21][2] =
// {
// //    0x00C31100, POWER_DOWN_RECORD_ADDR,             //掉电记录起始地址                                  0
//     0x00C31100, EVET_POWDN_03110001_00_OFFSET_ADDR, //掉电记录起始地址                                  0
// //    0x0CA33002, DEMAND_ZERO_RECORD_ADDR,            //需量清零记录起始地址                              1
//     0x0CA33002, EVET_DMDCLR_03300201_00_OFFSET_ADDR,//需量清零记录起始地址                              1
//     0x01033004, CHECK_TIME_RECORD_ADDR,             //校时记录起始地址                                  2
//     0x2AA33005, TABLE_PROGRAM_RECORD_ADDR,          //时段表编程记录起始地址                            3
//     0x05E33006, ZONE_PROGRAM_RECORD_ADDR,           //时区表编程记录起始地址                            4
//     0x40233008, HOLIDAY_PROGRAM_RECORD_ADDR,        //节假日编程记录起始地址                            5
//     0x00B33007, WEEKDAY_PROGRAM_RECORD_ADDR,        //周休日编程记录起始地址                            6
//     0x00B33009, COMB_Y_PROGRAM_RECORD_ADDR,         //有功组合方式编程记录起始地址                      7
//     0x00B3300A, COMB_1_PROGRAM_RECORD_ADDR,         //无功组合方式1 编程记录起始地址                    8
//     0x00B3300B, COMB_2_PROGRAM_RECORD_ADDR,         //无功组合方式2 编程记录起始地址                    9
//     0x0103300C, ACCOUNT_DAY_PROGRAM_RECORD_ADDR,    //结算日编程记录起始地址                            10

//     0x01401201, POS_ACTIVE_DEMAND_REC_ADDR,         //正向有功需量记录起始地址                          11
//     0x01401202, NEG_ACTIVE_DEMAND_REC_ADDR,         //反向有功需量记录起始地址                          12
//     0x01401203, QUADRANT_1_REACTIVE_DEMAND_REC_ADDR,//第一象限无功需量记录起始地址                      13
//     0x01401204, QUADRANT_2_REACTIVE_DEMAND_REC_ADDR,//第二象限无功需量记录起始地址                      14
//     0x01401205, QUADRANT_3_REACTIVE_DEMAND_REC_ADDR,//第三象限无功需量记录起始地址                      15
//     0x01401206, QUADRANT_4_REACTIVE_DEMAND_REC_ADDR,//第四象限无功需量记录起始地址                      16
//     0x00031200, POS_ACTIVE_DEMAND_COUNT_ADDR,       //正向有功需量超限总次数地址(依次各种需量超限的次数)17

// //    0x03233000, PROGRAM_RECORD_ADDR,                //编程记录起始地址                                  18
//     0x03233000, EVET_PRGTIME_03300000_00_ADDR,      //编程记录起始地址                                  18
//     0x06A33001, ENERGY_ZERO_RECORD_ADDR,            //电表清零记录起始地址                              19
//     0x00E33003, EVENT_ZERO_RECORD_ADDR,             //事件清零记录起始地址                              20
// };
//-----------对应上表标识码的记录的总次数的存储地址--------------------------
// static const U32 event_count_addr[21] =
// {
// //    POWER_DOWN_COUNT_ADDR,                  //掉电
//     EVET_POWDNTIME_03110000_00_ADDR,        //掉电
// //    DEMAND_ZERO_COUNT_ADDR,                 //需量清零总次数 10
//     EVET_DMDCLR_03300200_00_ADDR,           //需量清零总次数 10
//     CHECK_TIME_COUNT_ADDR,                  //校时总次数 10
//     TABLE_PROGRAM_COUNT_ADDR,               //时段表编程总次数  取178个,共672,分四次，后续为168,168,168
//     ZONE_PROGRAM_COUNT_ADDR,                //时区表编程总次数
//     HOLIDAY_PROGRAM_COUNT_ADDR,             //节假日编程总次数  取186，共1026个，分6次，后续176,176,176,176,136
//     WEEKDAY_PROGRAM_COUNT_ADDR,             //周休日编程总次数
//     COMB_Y_PROGRAM_COUNT_ADDR,              //有功组合方式编程总次数
//     COMB_1_PROGRAM_COUNT_ADDR,              //无功组合方式1 编程总次数
//     COMB_2_PROGRAM_COUNT_ADDR,              //无功组合方式2 编程总次数
//     ACCOUNT_DAY_PROGRAM_COUNT_ADDR,         //结算日编程总次数

//     POS_ACTIVE_DEMAND_COUNT_ADDR,           //正向有功需量超限总次数
//     NEG_ACTIVE_DEMAND_COUNT_ADDR,           //反向有功需量超限总次数
//     QUADRANT_1_REACTIVE_DEMAND_COUNT_ADDR,  //第一象限无功需量超限总次数
//     QUADRANT_2_REACTIVE_DEMAND_COUNT_ADDR,  //第二象限无功需量超限总次数
//     QUADRANT_3_REACTIVE_DEMAND_COUNT_ADDR,  //第三象限无功需量超限总次数
//     QUADRANT_4_REACTIVE_DEMAND_COUNT_ADDR,  //第四象限无功需量超限总次数
//     POS_ACTIVE_DEMAND_COUNT_ADDR,           //需量超限总次数起始地址(备注：各需量超限次数地址不连续)

// //    PROGRAM_TOTAL_COUNT_ADDR,               //编程总次数
//     EVET_PRGTIME_03300000_00_ADDR,          //编程总次数
//     ENERGY_ZERO_COUNT_ADDR,                 //电表清零总次数 10
//     EVENT_ZERO_COUNT_ADDR,                  //事件清零

// };

//-----------------------------------厂家设置使用--------------------------------
//--------按厂家设置规约排序的项的地址，跟下一个表格对应
//static const U32 produce_set_addr[] =
//{
//    ENG_COMPOSP_00000000_00_ADDR,           //组合有功    11个  0
//    ENG_POSP_00010000_00_ADDR,              //正向有功电能量    1
//    ENG_NEGP_00020000_00_ADDR,              //反向有功电能量    2
//    ENG_COMQ1_00030000_00_ADDR,             //组合1无功电能量   3
//    ENG_COMQ2_00040000_00_ADDR,             //组合2无功电能量   4
//    ENG_REA1Q_00050000_00_ADDR,             //象限1无功电能量   5
//    ENG_REA2Q_00060000_00_ADDR,             //象限2无功电能量   6
//    ENG_REA3Q_00070000_00_ADDR,             //象限3无功电能量   7
//    ENG_REA4Q_00080000_00_ADDR,             //象限4无功电能量   8
//    ENG_POSS_00090000_00_ADDR,              //正向视在电能量    9
//    ENG_NEGS_000A0000_00_ADDR,              //反向视在电能量    10
//    ENG_RELATOTP_00800000_00_ADDR,          //关联电能量  5个   B
//    ENG_APOSP_00150000_00_ADDR,             //A相电能           C
//    ENG_ARELATOTP_00940000_00_ADDR,         //A相关联电能       D
//    ENG_CPOSP_003D0000_00_ADDR,             //C相电能           E
//    ENG_CRELATOTP_00BC0000_00_ADDR,         //C相关联电能       F
//    PAR_VRATING_04000404_00_ADDR,           //额定电压(ASCII码)         10
//    PAR_IRATING_04000405_00_ADDR,           //额定电流(ASCII码)         11
//    PAR_IMAX_04000406_00_ADDR,              //最大电流(ASCII码)         12
//    PAR_PACCURACY_04000407_00_ADDR,         //有功准确度等级(ASCII码)   13
//    PAR_QACCURACY_04000408_00_ADDR,         //无功准确度等级(ASCII 码)  14
//    PAR_PCONSTANT_04000409_00_ADDR,         //电表有功常数              15
//    PAR_QCONSTANT_0400040A_00_ADDR,         //电表无功常数              16
//    PAR_HVMTYPE_0400040B_00_ADDR,           //电表型号(ASCII 码)        17
//    PAR_HVMTYPE_0400040B_TOT_LEN,           //生产日期(ASCII 码)        18
//    PAR_PROTOVER_0400040D_00_ADDR,          //协议版本号(ASCII 码)      19
//    PAR_SWVER_04800001_00_ADDR,             //厂家软件版本号(ASCII 码)  1A
//    PAR_HWVER_04800002_00_ADDR,             //厂家硬件版本号(ASCII 码)  1B
//    PAR_MFTNUM_04800003_00_ADDR             //厂家编号(ASCII 码)        1C
//};
////--------------对应上表设置地址的字节长度-------------------
//static const U8 produce_set_num[] =
//{
//    20,                 //组合有功电能数据块
//    20,                 //正向有功电能数据块
//    20,                 //反向有功电能数据块
//    20,                 //组合无功1 电能数据块
//    20,                 //组合无功2 电能数据块
//    20,                 //第一象限无功电能数据块
//    20,                 //第二象限无功电能数据块
//    20,                 //第三象限无功电能数据块
//    20,                 //第四象限无功电能数据块
//    20,                 //正向视在电能数据块
//    20,                 //反向视在电能数据块
//    20,                 //关联总电能（5项）
//    40,                 //A 相电能（10）项
//    20,                 //A 相关联电量5项
//    40,                 //C 相电能（10）项
//    20,                 //C 相关联电量（5）项
//    6,                  //额定电压(ASCII 码)
//    6,                  //额定电流(ASCII 码)
//    6,                  //最大电流(ASCII 码)
//    4,                  //有功准确度等级(ASCII 码)
//    4,                  //无功准确度等级(ASCII 码)
//    3,                  //电表有功常数
//    3,                  //电表无功常数
//    10,                 //电表型号(ASCII 码)
//    10,                 //生产日期(ASCII 码)
//    16,                 //协议版本号(ASCII 码)
//    32,                 //厂家软件版本号(ASCII 码)
//    32,                 //厂家硬件版本号(ASCII 码)
//    32                  //厂家编号(ASCII 码)
//};

//----------------------函数体----------------------------------------------------

/******************************************************************************
** 函数名称: U8 compare_total_id(U8 *id_buff, U32 *fram_buff, byte_num, U8 len)
** 函数功能: 把id_buff前byte_num字节跟fram_buff数组里元素低byte_num位比较，相等返回下标
** 入口参数: *id_buff : 需要解析的标识码
**           *fram_buff : 参照地址的表格指针
**           len:         表格长度
** 返 回 值: 返回对应数组的下标
** 说    明: 返回值为FF表示无对应数据,fram_buff只比较下标为偶数的元素。
******************************************************************************/
U8 compare_total_id (U8 *id_buff, const U32 *fram_buff, U8 byte_num, U8 len)
{
    U8 i;
    U32 id_data;
    U32 id_mask;

    id_data = 0;
    id_mask = 0;
    for(i = 0; i < byte_num; i++)
    {
        id_data <<= 8;
        id_data += id_buff[byte_num - 1 - i];
        id_mask <<= 8;
        id_mask |= 0xff;
    }
    for(i = 0; i < len; i++)
    {
        if(id_data == (id_mask & fram_buff[2 * i]))
        {
            return i;
        }
    }
    return 0xff;
}

/******************************************************************************
** 函数名称: U8 compare_id(U8 id_data, U8 *id_buff, U8 len)
** 函数功能: 把一个字节跟参照表里的数据进行比较，返回相同
** 入口参数: id_data : id2标识码
**           U8 *id_buff : 各类标识2的表格指针
**            len:         表格长度
** 返 回 值: 返回对应数组的下标
** 说    明: 返回值为FF表示无对应数据
******************************************************************************/
U8 compare_id (U8 id_data, const U8 *id_buff, U8 len)
{
    U8 i;

    for(i = 0; i < len; i++)
    {
        if(id_data == id_buff[i])
        {
            return i;
        }
    }
    return 0xff;
}

/******************************************************************************
** 函数名称: U8 cal_frmcs(U8 *buf, U16 len)
** 函数功能: 计算帧纵向校验码
** 入口参数: U8 *buf : 数据帧首地址
**           U16 len  : 数据帧长度
** 返 回 值: 校验码  范围:0-255
** 说    明: 数据帧长度是指从帧头0x68到数据域最后一个数据的长度。
******************************************************************************/
U8 cal_frmcs (U8 *buf, U16 len)
{
    U8 sum;
    U16 i;

    sum = 0;
    for(i = 0; i < len; i++)
    {
        sum += buf[i];
    }
    return sum;
}

/******************************************************************************
** 函数名称: S8 cmp_addr(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 检查表地址是否正确
** 入口参数: U8 *obj_buff : 需要解析的地址数组
**           U8 *rev_buff : 正确地址的存放数组
** 返 回 值: -1 ：地址错误
**            1 ：地址(A0 A1 A2 A3 A4 A5)或表号(N0 N1 N2 N3 N4 N5)
**            2 ：广播校时(99 99 99 99 99 99)
** 说    明: 跟通信地址比较错误时，会再跟表号比较一次，rev_buff的是通信地址，
**           输入的是地址（表号）时，相应的返回数组是实际的地址（表号）。
**           支持半字节寻址,占用rev_buff[0..11]。
******************************************************************************/
S8 cmp_addr (U8 *obj_buff, U8 *rev_buff)
{
    U8 i;

    memcpy(rev_buff, gMatch_HVMeter_Addr, PAR_HVMETER_ADR_LEN);

		for(i = 0; i < 6; i++)                      		//半字节寻址，遇A略过
        {
            if(((rev_buff[i] & 0x0f) != (obj_buff[i] & 0x0f)) && ((obj_buff[i] & 0x0f) != 0x0A))
            {
                break;
            }
            if(((rev_buff[i] & 0xf0) != (obj_buff[i] & 0xf0)) && ((obj_buff[i] & 0xf0) != 0xA0))
            {
                break;
            }
        }
        if(i > 5)
        {
            for(i = 0; i < 6; i++)
            {
                rev_buff[i] = rev_buff[i];  //把正确的表地址(表号)放到目标数组中去
            }
            return 1;                               //地址正确返回1
        }

    for(i = 0; i < 6; i++)                          //到此说明非正确地址，判断是否为广播地址
    {
        if(0x99 != obj_buff[i])
        {
            return -1;                              //不是广播地址，返回错误 -1
        }
    }
    return 2;                                       //广播地址，返回2
}

/******************************************************************************
** 函数名称: void decode_data(U8 *obj_buff, U8 *rev_buff, U8 len)
** 函数功能: 对数据进行减33H解码。
** 入口参数: U8 *obj_buff : 要处理的数据的首地址
**           U8 *rev_buff : 解码后的数据的存放地址
**           U8 len       : 要处理的数据字节数
** 返 回 值: 无
** 说    明: 当数据小于0x33时，加0xcd
******************************************************************************/
void decode_data (U8 *obj_buff, U8 *rev_buff, U8 len)
{
    U8 i;

    for(i = 0; i < len; i++)
    {
        if(obj_buff[i] < (U8)0x33)                  //非BCD码
        {
            rev_buff[i] = obj_buff[i] + 0xCD;       //0xcd = 0x100 - 0x33
        }
        else
        {
            rev_buff[i] = obj_buff[i] - 0x33;
        }
    }
}

/******************************************************************************
** 函数名称: S8 deal_with_DLT645frame(U8 index)
** 函数功能: 解析dlt645规约帧
** 入口参数: U8 index : 内存块下标
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: 需要用到内存块Sys_Mem[3]，当出现事件记录时，也会用到Sys_Mem[4]
******************************************************************************/
//S8 deal_with_DLT645frame (U8 index)
S8 deal_with_DLT645frame (U8 *InBuf)
{
    U8 mem_type;
    U8 aim_addr[8];//zigbee目标地址
    U8 rev_len,i,com;
    U8 temp;
    U8 *p_rev;
    U8 *p_send;
    U8 *send_buf;
    S8 addr_err;
    S8 err;
    U16 rxhead,revmaxlen;
    S32 data_len_send;
    U32 frame_len_send=0;
    U32 tmp;

    data_len_send = -1;
    rxhead=0;
    err = -1;
    com = convert_com_index(InBuf);
    if(0xff == com)
    {
        return __TRUE;
    }
#ifdef ZIGBEE_TEST
    if(com == ZIGBEE_CHL)//保存待返回返回zigbee目标地址
    {
        memcpy(aim_addr, InBuf+ZIGBEE_RET_ADDR_OFFSET, 8);
        memcpy(gMatch_aim_addr, InBuf+ZIGBEE_RET_ADDR_OFFSET, 8);//azh 171011 电子式高压表GPRS表上行规约被动模式下返回地址
        
    }
#endif
    p_rev = InBuf + DATA_OFFSET;
    revmaxlen = InBuf[DATA_LEN_OFFSET] + InBuf[DATA_LEN_OFFSET+1]*0x100;

    while(1)
    {

        p_send = alloc_comm_mem(MEM_256_TYPE, &mem_type, GET_MEM_ERR10);
        if(p_send   != NULL)
        {
            break;
        }
        else
        {
            setmemgetnullid(GET_MEM_ERR10, gusCurMemErrFunName);
        }
        os_dly_wait(2);
    }

framhead_adjust1:

    while(p_rev[rxhead++] != 0x68)                //帧头校验，必须为0x68,注意：当正确时，index已经加1
    {
        if((rxhead + 11) > revmaxlen)                 //判断剩余的数据是否大于一帧的最小长度（16）
        {
            free_mem_block(p_send);//Mem_256_Byte
            //azh 171017 上行规约的命令帧还要解析
            return -1;//return 1;
        }
    }

    if((rxhead + 11) > revmaxlen)                     //判断剩余的数据是否大于一帧的最小长度
    {
        free_mem_block(p_send);//Mem_256_Byte   //退出前释放内存块
        return -1;//return 1;
    }

    p_rev += (rxhead - 1);                   //把帧头0x68的指针赋给p_rev

    if(p_rev[7] != 0x68)                                        //判断帧的第八位是否为0x68
    {
        goto framhead_adjust1;
    }

    rev_len = p_rev[9] + 11;                                    //计算结束符的相对位置
    if((rev_len + rxhead) > revmaxlen)                //如果长度超出帧长，返回帧头校验
    {
        goto framhead_adjust1;
    }
    else if(p_rev[rev_len] != 0x16)                             //判断结束符，不对的返回帧头校验
    {
        goto framhead_adjust1;
    }

    temp = cal_frmcs(p_rev, (rev_len - 1));                     //计算校验码

    if(temp != p_rev[rev_len - 1])                              //比较校验码
    {
        goto framhead_adjust1;
    }
#ifdef ZIGBEE_TEST
	if(__FALSE == dis_self_handle_di(com, p_rev))//透传 并且不能减33需要原始数据
	{
		free_mem_block(p_send);
		return -1;
	}	
    if(p_rev[8] != 0x13 )//azh 171020 支持广播读通信地址
    {    
        if((com == ZIGBEE_CHL) && ((p_rev[8] & 0x80) == 0 ))//zigbee 通道不支持645命令读和写 只支持主动发出去返回来的回应帧
        {
            free_mem_block(p_send);//Mem_256_Byte   //退出前释放内存块
            return 1;
        }
    }
#endif
    decode_data((p_rev + 10), (p_rev + 10), p_rev[9]);

#if CODE_VER_TYPE==GPRS_MODULE_PRJ		//配合带CPU_GPRS模块
    if(com != ZIGBEE_CHL)
    {
        addr_err = cmp_addr(p_rev + 1, p_send + 1);                 //比较地址,正确（或缩位）就把正确的地址放到Sys_mem[4][1-6]
    }
    else
    {
        addr_err = 1;
    }
#else//H_METER_PRJ,WLS_CUR_PRJ
    addr_err = cmp_addr(p_rev + 1, p_send + 1);                 //比较地址,正确（或缩位）就把正确的地址放到Sys_mem[4][1-6]
#endif    
    if(addr_err == 1)                                           //正确的通信地址
    {
		//azh171019 电子式高压表由于要支持被动抄上行规约，所以要区分是抄回的数据，被动收到数据地模块MAC地址
	    #ifdef ZIGBEE_TEST
            if(((p_rev[8]&0x80) != 0)&&(gucGetZigbeeAddrFlag == 1))//标志是要通过zigbee广播地址 攻取zigbee地址并保存
            {
                store_zigbee_addr(&InBuf[ZIGBEE_RET_ADDR_OFFSET]);
                gucGetZigbeeAddrFlag = 0;
            }	
        #endif//ZIGBEE_TEST    	   
			switch(p_rev[8])
        {
//-------------远程升级功能相关命令(内部扩充)-----------
        case 0x0F:      //远程升级控制码

            break;
//-----------------读数据命令---------------------------
        case 0x11:
            switch(p_rev[13])
            {
            case 0:                                                                 //电能量数据标识
                data_len_send = deal_with_energy_frame(p_rev + 8,p_send + 10);
                break;
            case 1:                                                                 //最大需量及发生时间数据标识
                data_len_send = deal_with_demand_frame(p_rev + 8,p_send + 10);
                break;
            case 2:                                                                 //变量数据标识
                data_len_send = deal_with_variable_frame(p_rev + 8,p_send + 10);
                break;
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
            case 3:                                                                 //事件记录数据标识
//                 data_len_send = deal_with_event_record_frame(p_rev + 8,p_send + 10);
                break;
#endif
            case 4:                                                                 //参变量数据标识
                data_len_send = read_parameter_frame(p_rev + 8,p_send + 10);
                break;
            case 5:                                                                 //冻结数据标识
                data_len_send = deal_with_freeze_frame(p_rev + 8,p_send + 10);
                break;
            default:                                                                //标识错误处理函数
                data_len_send = deal_with_err_frame(p_send + 10, 0x02);
                break;
            }
            break;
//-----------------读后续帧-----------------------------
        case 0x12:
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
            data_len_send = deal_with_after_frame(p_rev + 8,p_send + 10);
#endif
            break;
//-----------------读通信地址命令-----------------------
        case 0x13:                                               //读通信地址
            if(p_rev[9] == 0)
            {
                data_len_send = 6;
                memcpy(p_send + 10, gMatch_HVMeter_Addr, PAR_HVMETER_ADR_LEN);//azh 110217
#ifdef ZIGBEE_TEST//azh 171020 高压表的地址最高字节固定改成88，为了区分645现场表地址和GPRS模块地址
                p_send[15] = 0x88;
#endif
                for(i = 0; i < 6; i++)
                {
                    p_send[10 + i] += 0x33;
                }
            }
            else
            {
                rxhead = rxhead + rev_len + 1;
                goto framhead_adjust1;                         //无异常应答
            }
            break;
//-----------------写数据命令--------------------------
        case 0x14:
            temp = check_password(p_rev + 14);                  //计算密码的权限
            tmp = p_rev[10] + (p_rev[11] << 8) + (p_rev[12] << 16) + (p_rev[13] << 24); //厂家标识码07000001
            if(p_rev[13] == 0x04)
            {
                data_len_send = write_parameter_frame(p_rev + 8, p_send + 10, temp);
            }
            else if(tmp == 0x07000001)
            {
//azh 110527
                data_len_send = write_produce_frame(p_rev + 8, p_send + 10, temp);
            }
            else
            {
                data_len_send = deal_with_err_frame(p_send + 10, 0x01);
            }
            break;
//-----------------写通信地址命令----------------------
        case 0x15:
            temp = check_password(p_rev + 9);
            if(p_rev[9] == 0x06)
            {
                data_len_send = 0;
                //err = file_write(PAR_HVMADDR_04000401_00_ADDR, p_rev + 10, 6);
                //azh 这里配置的通信地址 就匹配的高压表地址 同时还要特殊处理自动绑定zigbee地址 
                //并且不能是zigbee通道本配置
#ifdef ZIGBEE_TEST
                if(com != ZIGBEE_CHL)//保存待返回返回zigbee目标地址
                {
                    store_hvmeter_addr(p_rev + 10);
                    memset(aim_addr, 0xff, PAR_HVMETER_ZIGBEE_ADR_LEN);
                    store_zigbee_addr(aim_addr);//便于广播获得zigbee地址
                    init_search_data();
                    err = 1;
                }
                else
                {
                    err = -1;
                }    
#else
                err = -1;
#endif//ZIGBEE_TEST
                
                if(err == 1)
                {
                    for(i = 0; i < 6; i++)
                    {
                        p_send[1 + i] = p_rev[10 + i];
                    }
                }
                else
                {
                     data_len_send = -1;
                     p_rev[10] = err;
                }

            }
            else
            {
                rxhead = rxhead + rev_len;
                goto framhead_adjust1;                              //无异常应答
            }
            break;
//-----------------冻结命令---------------------------
/*
        case 0x16:

            if(p_rev[9] == 0x04)
            {
                temp = deal_with_instant_freeze(p_rev + 10);
                if(temp == 0)
                {
                    temp = check_freeze_time_valid (p_rev + 10);
                    if(temp)
                    {
                        file_write(FREEZE_TIME_ADDR, p_rev + 10, FREEZE_TIME_LEN);
                    }
                }
                if(temp)
                {
                    data_len_send = 0;
                }
                else
                {
                    data_len_send = deal_with_err_frame(p_send + 10, 0x01);
                }
            }
            else
            {
                data_len_send = deal_with_err_frame(p_send + 10, 0x01);
            }
            break;
*/
//------------------更改通信速率--------------------
/*
        case 0x17:
            baud_change_flag = 0;
            //if((Comm_Mem[index].Port_Num == RS485_1) && (p_rev[9] == 1))
            if((Com == RS485_1) && (p_rev[9] == 1))
            {
                data_len_send = 0;
                State_Machine[RS485_1].Send_Baud = State_Machine[RS485_1].Default_Baud;
                switch(p_rev[10])
                {
//                case 0x02:
//                    State_Machine[RS485_1].Default_Baud = (600 / 300);
//                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
//                    break;
//                case 0x04:
//                    State_Machine[RS485_1].Default_Baud = (1200 / 300);
//                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
//                    break;
                case 0x08:
                    State_Machine[RS485_1].Default_Baud = (2400 / 300);
                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
                    break;
                case 0x10:
                    State_Machine[RS485_1].Default_Baud = (4800 / 300);
                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
                    break;
                case 0x20:
                    State_Machine[RS485_1].Default_Baud = (9600 / 300);
                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
                    break;
                case 0x40:
                    State_Machine[RS485_1].Default_Baud = (19200 / 300);
                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
                    break;
                case 0x80:
                    State_Machine[RS485_1].Default_Baud = (38400 / 300);
                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
                    break;
                case 0x81:
                    State_Machine[RS485_1].Default_Baud = (57600 / 300);
                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
                    break;
                case 0x82:
                    State_Machine[RS485_1].Default_Baud = (115200 / 300);
                    file_write(BAUD_RATE_CHARACTER_ADDR + 4, &p_rev[10], 1);
                    break;
                default:
                    State_Machine[RS485_1].Send_Baud = DEFAULT_BAUD_RATE;
                    data_len_send = deal_with_err_frame(p_send + 10, 0x01);
                    break;
                }
                if(data_len_send == 0)
                {
                    p_send[10] = p_rev[10] + 0x33;
                    data_len_send = 1;
                    after_fram_flag = 0;
                    baud_change_flag = 1;
                }
            }
            else
            {
                data_len_send = deal_with_err_frame(p_send + 10, 0x08);
            }
            break;
*/
//------------------修改密码------------------------
        case 0x18:
            data_len_send = set_password(p_rev + 8, p_send + 10);
            break;
//------------------最大需量清零---------------------
/*
        case 0x19:

            if(p_rev[9] == 8)
            {
                temp = check_password(p_rev + 10);
                if(temp < 6)                                                //密码权限为4级，对应6
                {
                    data_len_send = deal_with_err_frame(p_send + 10, 0x04); //密码权限不足或错误
                }
                memcpy((U8 *)Sys_Mem[4] + 6, p_rev + 14, 4);
                record_demand_zero_event((U8 *)Sys_Mem[4]);                 //记录清需量事件
                max_demand_reset();
                data_len_send = 0;
            }
            else
            {
                data_len_send = deal_with_err_frame(p_send + 10, 0x01);
            }
            break;
*/
//-----------------电表清零-------------------------
/*
        case 0x1A:
            if(p_rev[9] == 8)
            {
                temp = check_password(p_rev + 10);
                if(temp > 7)
                {
                    memcpy((U8 *)Sys_Mem[4] + 6, p_rev + 14, 4);        //获取操作者代码
                    record_energy_zero_event((U8 *)Sys_Mem[4]);         //记录清电表事件
                    clear_energy();                                     //清电能量底度
                    clear_freeze_data();                                //清冻结数据
                    clear_load_profile_data();                          //负荷记录清零
                    max_demand_reset();                                 //清最大需量

                    Sys_Mem[4][0] = 0;
                    for(i = 0; i < 12; i++)                             //事件清零
                    {
                        file_write(event_count_addr[i], (U8 *)Sys_Mem[4], 3);
                    }
                    for(i = 13; i < 18; i++)
                    {
                        file_write(event_count_addr[i], (U8 *)Sys_Mem[4], 3);
                    }

                    Sys_Mem[4][2] = 0xffffffff;
                    Sys_Mem[4][3] = 0xffffffff;
                    memcpy((U8 *)&Sys_Mem[4] + 6, p_rev + 14, 4);       //操作者代码在帧的p_rev[14]

                    record_event_zero_event((U8 *)Sys_Mem[4]);          //事件清零记录
                    data_len_send = 0;
                }
                else
                {
                    data_len_send = deal_with_err_frame(p_send + 10, 0x04);     //密码权限不足或错误
                }
            }
            else
            {
                data_len_send = deal_with_err_frame(p_send + 10, 0x01);
            }
            break;
//-----------------事件清零-------------------------
        case 0x1B:
            data_len_send = deal_with_clear_event_frame(p_rev + 8,p_send + 10);
            break;
*/
//------------------电表返回数据帧------------------
        case 0x91://本地解析并保存
            err = deal_with_initiative_frame(p_rev + 9);                        //传递数据长度等信息
//            err = 1;                                                            //正确帧处理标识
            rxhead = rxhead + rev_len;                                          //指针指向下一帧
            goto framhead_adjust1;                                              //处理完一帧返回接着处理连帧
        default:                                                                //其他功能码错误
            rxhead = rxhead + rev_len;                                          //指针指向下一帧
            goto framhead_adjust1;                                              //处理完一帧返回接着处理连帧。
        }
//-----------------组装其他数据域以外的其他帧组成-----
        p_send[0] = 0x68;                                                       //把帧头装入Sys_mem[4][0]
        p_send[7] = 0x68;

        if(data_len_send < -1)
        {
            goto framhead_adjust1;                                              //处理完一帧返回接着处理连帧。
        }
        else if(data_len_send == -1)                                            //异常应答
        {
            p_send[8] = p_rev[8] | 0xC0;                                        //装入功能码
            p_send[9] = 1;                                                      //装入数据域长度
        }
        else                                                                    //正常应答
        {
            p_send[8] = p_rev[8] | 0x80;                                        //装入功能码
            if(after_fram_flag == 1)
            {
                p_send[8] = p_send[8] | 0x20;
                after_fram_flag = 0;
            }
            p_send[9] = data_len_send;
        }
        frame_len_send = 12 +  p_send[9];                                       //整个帧长度
        p_send[frame_len_send - 2 ] = cal_frmcs(p_send, (frame_len_send - 2));  //装入CS码
        p_send[frame_len_send - 1] = 0x16;                                      //装入结束符

//azh 110524
        send_buf = alloc_comm_mem(MEM_256_TYPE, &mem_type, GET_MEM_ERR11);
        if(send_buf != NULL)
        {
            if(0x93 != p_send[8])
            {
                memcpy(&send_buf[ZIGBEE_RET_ADDR_OFFSET], aim_addr, 8);         //zigbee待发送目标地址
            }
            else
            {
                memset(&send_buf[ZIGBEE_RET_ADDR_OFFSET], 0xff, 8);             //应用层广播地址, 采用广播回应, 避免接收侧拥堵
            }
            memcpy(&send_buf[DATA_OFFSET], p_send, frame_len_send);
            send_protocol_frame(send_buf, com, frame_len_send, MEM_256_TYPE);
        }
        else
        {
//          memcpy(gusCurMemErrFunName, "deal_wi2", 8);
            setmemgetnullid(GET_MEM_ERR11, gusCurMemErrFunName);
        }

/*

        i = alloc_comm_mem();

        if(0xff != i)
        {
            if(baud_change_flag)
            {
                Comm_Mem[i].Send_Baud = State_Machine[Comm_Mem[index].Port_Num].Send_Baud;
                baud_change_flag = 0;
            }
            p_rev = &Comm_Mem[i].Buf[0];
            memcpy(p_rev, p_send, frame_len_send);
            Comm_Mem[i].Len = frame_len_send;
            Comm_Mem[i].Port_Num = Comm_Mem[index].Port_Num;
            if(uart_send(i) == __FAIL)
            {
                Comm_Mem[i].Flag = 0;
            }
        }
*/
    }
    else if(addr_err == 2)                                      //广播地址
    {
        if((p_rev[8] == 0x08) && (p_rev[9] == 0x06))            //广播校时
        {
            frame_len_send = p_rev[13] + ((U16)p_rev[14] << 8); //取广播过来的月、日
            temp = check_radio_time_valid(p_rev + 10);
            if(temp)                                            //判断校时数据是否有效
            {
                if(radio_date != frame_len_send)                //比较上一次校时和这一次校时的月日，每天只允许较一次
                {
                    get_sys_date((U8 *)&data_len_send);
                    data_len_send = ((U32)data_len_send >> 8) - frame_len_send - ((U32)p_rev[15] << 16);
                    if(data_len_send == 0)                      //比较广播日期和当前日期
                    {
                        file_read(HARDWARE_RTC_ADDR, (U8 *)&data_len_send, 3);
                        data_len_send = (((data_len_send >> 16) & 0xff) - p_rev[12]) * 3600     //计算当前时间和校时相差多少秒
                            + (((data_len_send >> 8) & 0xff) - p_rev[11]) * 60 + (data_len_send & 0xff) - p_rev[10];
                        if(abs(data_len_send) <= 300)
                        {
                            set_sys_calendar(p_rev + 10);       //调用校时函数
                            radio_date = frame_len_send;        //更新上一次的校时月日
                        }
                    }

                }
            }
        }
        else if((p_rev[8] == 0x16) && (p_rev[9] == 0x04))       //广播冻结
        {
/*            temp = deal_with_instant_freeze(p_rev + 10);
            if(temp == 0)
            {
                temp = check_freeze_time_valid (p_rev + 10);
                if(temp)
                {
                    file_write(FREEZE_TIME_ADDR, p_rev + 10, FREEZE_TIME_LEN);
                }
            }
*/
        }
    }
    err = 1;                                                    //正确帧处理标识
    rxhead = rxhead + rev_len;                                  //指针指向下一帧
    goto framhead_adjust1;                                      //处理完一帧返回接着处理连帧。

}

/******************************************************************************
** 函数名称: S32 deal_with_energy_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 解析电能量数据标识帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**           码开始，已加0x33。
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: obj_buff[2],ID0:当前或结算日
**           obj_buff[3],ID1:费率
**           obj_buff[4],ID2:小类
**           obj_buff[5],ID3:大类
******************************************************************************/
S32 deal_with_energy_frame (U8 *obj_buff, U8 *rev_buff)
{
    S32 len;                                            //返回值
    U8 i, j, k;
    U8 point;
    U8 point_offset;
    U8 index;                                           //小类地址下标
    U8 data_len;
    U32 obj_addr;                                       //目标地址
    U32 fee_addr;                                       //费率偏移地址

    index = compare_id (obj_buff[4], energy_id2, 46);
    if((index == 0xff) || ((obj_buff[2] > 0x0c) && (obj_buff[2] != 0xff)))     //小类错或结算日数超
    {
        goto id_err_deal2;
    }

    if((index > 10) && (obj_buff[3] != 0))                       //单相需量费率必须为0
    {
        goto id_err_deal2;
    }

//-----------计算费率号造成的偏移
    if(obj_buff[3] == 0xff)                                     //数据块
    {
        fee_addr = 0;
        data_len = ACCOUNT_TOTAL_PHASE_ENERGY_LEN;
    }
    else if(obj_buff[3] > RATE_NUM)                             //费率超
    {
        len = deal_with_err_frame(rev_buff, 0x40);
        return len;
    }
    else
    {
        fee_addr = obj_buff[3] * ENERGY_LEN;
        data_len = ENERGY_LEN;
    }

    switch(index)
    {                           //参照表格energy_id2[]下标
    case 0:                     //有功组合
    case 3:                     //无功组合1
    case 4:                     //无功组合2
    case 11:                    //关联总电能
    case 18:                    //A相无功组合1
    case 19:                    //A相无功组合2
    case 26:                    //A相关联电能
    case 33:                    //C相无功组合1
    case 34:                    //C相无功组合2
    case 41:                    //C相关联电能
        j = 0;
        break;
    default:
        j = 0xff;
        break;
    }
    if(obj_buff[2] == 0)                                        //当前值
    {
        obj_addr = current_energy_addr[index] + fee_addr;
        file_read(obj_addr, rev_buff + 4, data_len);
    }
    else if(obj_buff[2] == 0xff)                                //当前和结算日合集
    {
        if(obj_buff[3] == 0xff)
        {
            goto id_err_deal2;
        }

        obj_addr = current_energy_addr[index] + fee_addr;       //当前处理
        file_read(obj_addr, rev_buff + 4, data_len);
        file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, (U8 *)&point, 1);   //读取结算日当前指针
        for(i = 1; i < 13; i++)
        {
            point_offset = decrease_event_record_point(point, ACCOUNT_DAY_DATA_NUM, i);
            if(__FAIL == (S8)point_offset)
            {
                for(j = i; j < 13; j++)
                {
                    for(k = 0; k < data_len; k++)
                    {
                        rev_buff[4 + k +j * data_len] = 0;
                    }
                }
                break;
            }
            else
            {
                point_offset &= 0x7f;
                obj_addr = point_offset * SINGLE_ACCOUNT_DAY_DATA_LEN + account_energy_addr[index] + fee_addr;
                file_read(obj_addr, rev_buff + 4 + i * data_len, data_len);
            }
        }
        data_len = data_len * 13;
    }
    else                                                       //某个结算日
    {
        file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, (U8 *)&point, 1);
        point_offset = decrease_event_record_point(point, ACCOUNT_DAY_DATA_NUM, obj_buff[2]);
        if(__FAIL == (S8)point_offset)
        {
            goto id_err_deal2;
        }
        else
        {
            point_offset &= 0x7f;
        }
        obj_addr = point_offset * SINGLE_ACCOUNT_DAY_DATA_LEN + account_energy_addr[index] + fee_addr;
        file_read(obj_addr, rev_buff + 4, data_len);
    }

    for(i = 0; i < data_len; i++)
    {
        rev_buff[4 + i] += 0x33;
    }
    for(i = 0; i < 4; i++)
    {
        rev_buff[i] = obj_buff[i + 2] + 0x33;
    }
    len = 4 + data_len;

    after_fram_flag = 0;
    return len;

id_err_deal2:
    len = deal_with_err_frame(rev_buff, 0x02);
    return len;

}

/******************************************************************************
** 函数名称: S32 deal_with_demand_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 解析需量数据标识帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**           码开始，已加0x33。
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: obj_buff[2],ID0:当前或结算日
**           obj_buff[3],ID1:费率
**           obj_buff[4],ID2:小类
**           obj_buff[5],ID3:大类
******************************************************************************/
S32 deal_with_demand_frame (U8 *obj_buff, U8 *rev_buff)
{
    S32 len;                                            //返回值
    U8 i, j, k;
    U8 point;
    U8 point_offset;
    U8 index;                                           //小类地址下标
    U8 data_len;
    U32 obj_addr;                                       //目标地址
    U32 fee_addr;                                       //费率偏移地址

    index = compare_id (obj_buff[4], demand_id2, 30);
    if((index == 0xff) || ((obj_buff[2] > 0x0c) && (obj_buff[2] != 0xff)))     //小类错或结算日数超
    {
        len = deal_with_err_frame(rev_buff, 0x01);
        return len;
    }

    if((index > 9) && (obj_buff[3] != 0))               //单相需量费率必须为0
    {
        len = deal_with_err_frame(rev_buff, 0x01);
        return len;
    }
//-----------计算费率号造成的偏移
    if(obj_buff[3] == 0xff)
    {
        fee_addr = 0;
        data_len = TOTAL_PHASE_DEMAND_LEN;
    }
    else if(obj_buff[3] > RATE_NUM)                     //费率超
    {
        len = deal_with_err_frame(rev_buff, 0x40);
        return len;
    }
    else
    {
        fee_addr = (U16)obj_buff[3] * DEMAND_LEN;
        data_len = DEMAND_LEN;
    }

    if(obj_buff[2] == 0)                                //当前值
    {
        obj_addr = current_demand_addr[index] + fee_addr;
        file_read(obj_addr, rev_buff + 4, data_len);
        for(i = 0; i < data_len; i++)
        {
            rev_buff[4 + i] += 0x33;
        }
    }
    else if(obj_buff[2] == 0xff)                        //当前和结算日合集
    {
        if(obj_buff[3] == 0xff)
        {
            len = deal_with_err_frame(rev_buff, 0x01);
            return len;
        }

        obj_addr = current_demand_addr[index] + fee_addr;
        file_read(obj_addr, rev_buff + 4, data_len);

        file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, (U8 *)&point, 1);   //读取结算日当前指针
        for(i = 1 ;i < 13; i++)
        {
            point_offset = decrease_event_record_point(point, ACCOUNT_DAY_DATA_NUM, i);
            if(__FAIL == (S8)point_offset)
            {
                for(j = i; j < 13; j++)
                {
                    for(k = 0; k < data_len; k++)
                    {
                        rev_buff[4 + k +j * data_len] = 0;
                    }
                }
                break;
            }
            else
            {
                point_offset &= 0x7f;
                obj_addr = point_offset * SINGLE_ACCOUNT_DAY_DATA_LEN + account_demand_addr[index] + fee_addr;
                file_read(obj_addr, rev_buff + 4 + i * data_len, data_len);
            }
        }
        data_len = data_len * 13;
        for(i = 0; i <data_len; i++)
        {
            rev_buff[4 + i] += 0x33;
        }
    }
    else                                                //某个结算日
    {
        file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, (U8 *)&point, 1);
        point_offset = decrease_event_record_point(point, ACCOUNT_DAY_DATA_NUM, obj_buff[2]);
        if(__FAIL == (S8)point_offset)
        {
            len = deal_with_err_frame(rev_buff, 0x02);
            return len;
        }
        else
        {
            point_offset &= 0x7f;
        }
        obj_addr = point_offset * SINGLE_ACCOUNT_DAY_DATA_LEN + account_demand_addr[index] + fee_addr;
        file_read(obj_addr, rev_buff + 4, data_len);
        for(i = 0; i < data_len; i++)
        {
            rev_buff[4 + i] += 0x33;
        }
    }

    for(i = 0; i < 4; i++)
    {
        rev_buff[i] = obj_buff[i + 2] + 0x33;
    }
    len = 4 + data_len;

    after_fram_flag = 0;
    return len;


}

/******************************************************************************
** 函数名称: S32 deal_with_variable_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 解析变量数据标识帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**           码开始，已加0x33。
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: obj_buff[2],ID0:当前,只能为00
**           obj_buff[3],ID1:相位
**           obj_buff[4],ID2:小类
**           obj_buff[5],ID3:大类
******************************************************************************/

S32 deal_with_variable_frame (U8 *obj_buff, U8 *rev_buff)
{
    S32 len;                                            //返回值
    U16 var_num;                                        //变量在U32 gVarArray[]数组中的下标
    U8 i;
    U8 phase_num;
    U8 id2,id1,id0;                                     //数据表示
    U8 data_len;

    phase_num = 1;
    data_len = 0;
    id0 = obj_buff[2];                //保存DI0
    id1 = obj_buff[3];                //保存DI1
    id2 = obj_buff[4];                //保存DI2
    if((id2 <= 7) && (id0 == 0))
    {
        id2 -= 1;           //转化为数组下标
        data_len = variable_frm[id2][5];

        switch(id1)
        {
        case 0://合相
        case 1://A 相
        case 2://B 相
        case 3://C 相
            var_num = (U16)variable_frm[id2][id1];//屏蔽掉存储器类型，只取低半字有效数组下标
            if(var_num > VAR_RAM_ARRAY_MAX)
            {
               return -1;
            }
            memcpy(rev_buff + 4, (U8 *)&gVarArray[var_num], data_len);
            break;
        case 0xff:
            if(variable_frm[id2][4] == 4)
            {
                var_num = (U16)variable_frm[id2][0];
                if(var_num > VAR_RAM_ARRAY_MAX)
                {
                   return -1;
                }
                memcpy(rev_buff + 4, (U8 *)&gVarArray[var_num], data_len * 4);
            }
            else
            {
                var_num = (U16)variable_frm[id2][1];
                if(var_num > VAR_RAM_ARRAY_MAX)
                {
                   return -1;
                }
                memcpy(rev_buff + 4, (U8 *)&gVarArray[var_num], data_len * 3);
            }
            phase_num = variable_frm[id2][4];
            break;
        default:
            len = deal_with_err_frame(rev_buff, 0x01);
            return len;
        }
    }
    else if(id2 == 0x80)   //0x80
    {
        switch(id0)
        {
        case 1:             //零线电流
            break;
        case 2:             //电网频率
            rev_buff[4] = gVarArray[VAR_FREQ_02800002_00_ADDR & 0xFFFF];
            rev_buff[5] = gVarArray[VAR_FREQ_02800002_00_ADDR & 0xFFFF] >> 8;
            data_len = VAR_FREQ_02800002_00_LEN;
            break;
        case 3:             //一分钟有功总平均功率
            rev_buff[4] = gVarArray[VAR_AVEPMIN_02800003_00_ADDR & 0xFFFF];
            rev_buff[5] = gVarArray[VAR_AVEPMIN_02800003_00_ADDR & 0xFFFF] >> 8;
            rev_buff[6] = gVarArray[VAR_AVEPMIN_02800003_00_ADDR & 0xFFFF] >> 16;
            data_len = VAR_AVEPMIN_02800003_00_LEN;
            break;
        case 4:             //当前有功需量
            rev_buff[4] = gVarArray[VAR_DMDP_02800004_00_ADDR & 0xFFFF];
            rev_buff[5] = gVarArray[VAR_DMDP_02800004_00_ADDR & 0xFFFF] >> 8;
            rev_buff[6] = gVarArray[VAR_DMDP_02800004_00_ADDR & 0xFFFF] >> 16;
            data_len = VAR_DMDP_02800004_00_LEN;
            break;
        case 5:             //当前无功需量
            rev_buff[4] = gVarArray[VAR_DMDQ_02800005_00_ADDR & 0xFFFF];
            rev_buff[5] = gVarArray[VAR_DMDQ_02800005_00_ADDR & 0xFFFF] >> 8;
            rev_buff[6] = gVarArray[VAR_DMDQ_02800005_00_ADDR & 0xFFFF] >> 16;
            data_len = VAR_DMDQ_02800005_00_LEN;
            break;
        case 6:             //当前视在需量
            rev_buff[4] = gVarArray[VAR_DMDS_02800006_00_ADDR & 0xFFFF];
            rev_buff[5] = gVarArray[VAR_DMDS_02800006_00_ADDR & 0xFFFF] >> 8;
            rev_buff[6] = gVarArray[VAR_DMDS_02800006_00_ADDR & 0xFFFF] >> 16;
            data_len = VAR_DMDS_02800006_00_LEN;
            break;
        case 7:             //表内温度
            rev_buff[4] = gVarArray[VAR_TEMPIN_02800007_00_ADDR & 0xFFFF];
            rev_buff[5] = gVarArray[VAR_TEMPIN_02800007_00_ADDR & 0xFFFF] >> 8;
            data_len = VAR_TEMPIN_02800007_00_LEN;
            break;
        case 8:             //时钟电池电压(内部)
            rev_buff[4] = gVarArray[VAR_VRTCBAT_02800008_00_ADDR & 0xFFFF];
            rev_buff[5] = gVarArray[VAR_VRTCBAT_02800008_00_ADDR & 0xFFFF] >> 8;
            data_len = VAR_VRTCBAT_02800008_00_LEN;
            break;
        default:
            len = deal_with_err_frame(rev_buff, 0x01);
            return len;
        }

    }
    else                                            //小类错或结算日数超
    {
        len = deal_with_err_frame(rev_buff, 0x01);
        return len;
    }
    for(i = 0; i < 4; i++)
    {
        rev_buff[i] = obj_buff[i + 2] + 0x33;
    }                                               //数据区填充
    for(i = 0; i < data_len * phase_num; i++)
    {
        rev_buff[4 + i ] += 0x33;                   //数据区填充
    }

    len = 4 + data_len * phase_num;
    after_fram_flag = 0;
    return len;
}

// /******************************************************************************
// ** 函数名称: S32 deal_with_event_record_frame(U8 *obj_buff, U8 *rev_buff)
// ** 函数功能: 解析事件记录数据标识帧
// ** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
// **           码开始，已加0x33。
// ** 返 回 值: len :数据域长度，
// **           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
// ** 说    明: 当解析错误
// ******************************************************************************/
// S32 deal_with_event_record_frame (U8 *obj_buff, U8 *rev_buff)
// {
//     U8 i,index;
//     U16 data_len;
//     U32 tmp;            //请求数据记录的总次数缓存
//     S32 len;

//     tmp = 0;
//     index = compare_total_id(obj_buff + 3, event_recond_addr[0], 2, 21);        //标识参照表返回下标
//     if(index == 0xff)                                                           //无相同标识
//     {
//         goto event_err_deal;
//     }
//     file_read(event_count_addr[index], (U8 *)(&tmp), 3);                        //读取请求项的记录次数
//     if(bcd_to_bytes((U8 *)(&tmp), 3) == 0)                  //次数数据是否有效
//     {
//         tmp = 0;
//         file_write(event_count_addr[index], (U8 *)(&tmp), 3);
//     }
//     if(obj_buff[2] == 0)                                    //请求记录总次数
//     {
//         if(17 == index)                                     //该标识为对应的所有分项需量记录次数，共3*6个字节
//         {
//             for(i = 1; i < 7; i++)
//             {
//                 file_read(event_count_addr[index + i - 6], (U8 *)(&tmp), 3);    //读取请求项的记录次数
//                 if(bcd_to_bytes((U8 *)(&tmp), 3) == 0)                          //次数数据是否有效
//                 {
//                     tmp = 0;
//                     file_write(event_count_addr[index + i], (U8 *)(&tmp), 3);
//                 }
//                 rev_buff[1 + i * 3] = tmp;
//                 rev_buff[2 + i * 3] = (tmp >> 8);
//                 rev_buff[3 + i * 3] = (tmp >> 16);
//             }
//             data_len =3 * 6;
//         }
//         else
//         {
//             rev_buff[4]=tmp;
//             rev_buff[5]=(tmp >> 8);
//             rev_buff[6]=(tmp >> 16);
//             data_len = 3;
//         }
//         after_fram_flag = 0;
//     }
//     else if((obj_buff[2] > 10) || (tmp < obj_buff[2]))      //记录数超过10或超过记录的总次数
//     {
//         goto event_err_deal;                                //标识码错误
//     }
//     else
//     {
//         if(17 == index)                                   //该标识为对应的所有分项需量记录次数，obj_buff[2]只能为0
//         {
//             goto event_err_deal;                            //标识码错误
//         }
//         else
//         {
//             tmp &= 0xf;
//             if(tmp >= obj_buff[2])
//             {
//                 tmp -= obj_buff[2];
//             }
//             else
//             {
//                 tmp += (10 - obj_buff[2]);
//             }
//             data_len = (event_recond_addr[index][0] >> 20) ;
//             if(data_len <= MAX_DATA_LEN)                    //长度是否超过最长
//             {
//                 after_fram_flag = 0;
//             }
//             else                                            //超了，要做后续帧处理
//             {
//                 After_Frame[0].State = 1;              //后续帧有效标识
//                 after_fram_flag = 1;
//                 After_Frame[0].Current_Seq = 1;
//                 After_Frame[0].Spare_Len = data_len - MAX_DATA_LEN;
//                 After_Frame[0].Tick = OS_Time;//Sys_Tick;
//                 After_Frame[0].Id[0] = obj_buff[2];
//                 After_Frame[0].Id[1] = obj_buff[3];
//                 After_Frame[0].Id[2] = obj_buff[4];
//                 After_Frame[0].Id[3] = obj_buff[5];
//                 After_Frame[0].Address = event_recond_addr[index][1] + tmp * data_len + MAX_DATA_LEN;
//                 data_len = MAX_DATA_LEN;
//             }
//             file_read(event_recond_addr[index][1] + tmp * (event_recond_addr[index][0] >> 20), rev_buff + 4, data_len);
//         }
//     }
//     for(i = 0; i < 4; i++)
//     {
//         rev_buff[i] = obj_buff[i + 2];
//     }
//     len = data_len + 4;
//     for(i = 0; i< len; i++)
//     {
//         rev_buff[i] += 0x33;
//     }
//     return len;

// event_err_deal:                                 //无请求数据统一处理
//     len = deal_with_err_frame(rev_buff, 2);
//     return len;

// }
/******************************************************************************
** 函数名称: S32 read_parameter_frame (U8 *obj_buff, U8 *rev_buff)
** 函数功能: 解析参变量数据读帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**           码开始，已加0x33。
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: obj_buff[2],ID0:细分
**           obj_buff[3],ID1:
**           obj_buff[4],ID2:小类
**           obj_buff[5],ID3:大类
******************************************************************************/
S32 read_parameter_frame (U8 *obj_buff, U8 *rev_buff)
{
    U8 i;
    U8 index;
    U8 data_len;
    S32 len;

    if((obj_buff[4] == 4) && (obj_buff[2] < 255))    //如果是循显相关
    {
        switch(obj_buff[3])
        {
        case 1:             //自动循环显示
            data_len = PAR_LOOPDIS1_04040101_00_LEN + 1;
            file_read((PAR_LOOPDIS1_04040101_00_ADDR + (obj_buff[2] - 1) * data_len), rev_buff + 4, data_len);
            break;
        case 2:             //按键循环显示
            data_len = PAR_KEYDIS1_04040201_00_LEN + 1;
            file_read((PAR_KEYDIS1_04040201_00_ADDR + (obj_buff[2] - 1) * data_len), rev_buff + 4, data_len);
            break;
        default:
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        for(i = 0; i < 4; i++)                  //标识码填充
        {
            rev_buff[i] = obj_buff[i + 2];
        }
        len = data_len + 4;

        for(i =0; i < len; i++)                 //加0x33
        {
            rev_buff[i] += 0x33;
        }
        after_fram_flag = 0;
        return len;
    }

    index = compare_total_id(obj_buff + 2, parameter_frm[0], 3, PAR_FRM_NUM);        //除了时区、段、假表以外的参变量标识码

    if(index == 0xff)
    {
        if((obj_buff[3] == 0x05) && (obj_buff[4] == 0))                     //电表状态字
        {
            if(obj_buff[2] == 0xff)                                         //全部电表状态字
            {
                data_len = 2 * 7;
                for(i = 0; i < 7; i++)
                {
                    rev_buff[4 + 2 * i] = gMeter_State[i];
                    rev_buff[5 + 2 * i] = (gMeter_State[i] >> 8);
                }
            }
            else if((obj_buff[2] > 0) && (obj_buff[2] <= 7))                //某一个电表状态字
            {
                data_len = 2;
                rev_buff[4] = gMeter_State[obj_buff[2] - 1];
                rev_buff[5] = (gMeter_State[obj_buff[2] - 1] >> 8);
            }
            else                                                            //标识码ID0错了
            {
                len = deal_with_err_frame(rev_buff, 2);
                return len;
            }
        }
        else
        {
            i = compare_total_id(obj_buff + 3, time_table_frm[0], 2, 3);    //时区、段、假表标识参照表返回下标
            if(i == 0xff)
            {
                len = deal_with_err_frame(rev_buff, 2);
                return len;
            }
            else
            {
                if(obj_buff[2] > (time_table_frm[i][0] >> 24) || ((obj_buff[2] == 0) && (i == 2)))//标识码ID0错
                {
                    len = deal_with_err_frame(rev_buff, 2);
                    return len;
                }
                data_len = (time_table_frm[i][0] >> 16);
                file_read(time_table_frm[i][1] + (U8)(time_table_frm[i][0] >> 16) * obj_buff[2], rev_buff + 4, data_len);
            }
        }
    }
    else if(index > PAR_FRM_NUM)            //异常
    {
        len = deal_with_err_frame(rev_buff, 1);
        return len;
    }
    else if(index == 34)                    //日期和周
    {
        data_len = (parameter_frm[index][0] >> 24);
        get_sys_date(rev_buff + 4);
    }
//并轨道下边else段
//    else if(index == 35)                    //脉冲宽度
//    {
//        data_len = 2;
//        rev_buff[4] = PULSE_WIDTH;
//        rev_buff[5] = (PULSE_WIDTH >> 8);
//    }
    else                                    //参见表parameter_frm[][]
    {
        data_len = (parameter_frm[index][0] >> 24);
        file_read(parameter_frm[index][1], rev_buff + 4, data_len);
    }

    for(i = 0; i < 4; i++)                  //标识码填充
    {
        rev_buff[i] = obj_buff[i + 2];
    }
    len = data_len + 4;

    for(i =0; i < len; i++)                 //加0x33
    {
        rev_buff[i] += 0x33;
    }
    after_fram_flag = 0;
    return len;

}
/******************************************************************************
** 函数名称: S32 write_parameter_frame(U8 *obj_buff, U8 *rev_buff, U8 pswd)
** 函数功能: 解析参变量数据设定帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**           码开始，已加0x33。pswd为密码权限等级，越大，等级越高,权限越小
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: obj_buff[2],ID0:细分
**           obj_buff[3],ID1:
**           obj_buff[4],ID2:小类
**           obj_buff[5],ID3:大类
******************************************************************************/
S32 write_parameter_frame (U8 *obj_buff, U8 *rev_buff, U8 pswd)
{
    U8 mem_type;
    U8 *t_buf;
    U8 i,index;
    U8 data_len;
    U16 tmp;
    S32 len;
    S32 err;

    if((obj_buff[4] == 4) && (obj_buff[2] < 255))    //如果是循显相关
    {
        if((pswd < password_popedom[57]) || (pswd < password_popedom[61]))  //密码权限不足
        {
            len = deal_with_err_frame(rev_buff, 4);
            return len;
        }
        if((obj_buff[1] != 0x10) && (obj_buff[1] != 0x11))                  //数据长度错
        {
            len = deal_with_err_frame(rev_buff, 1);
            return len;
        }

        if(obj_buff[1] == 0x10)
        {
            obj_buff[18] = 0xff;        //填补扩展小标识为0xFF(放在高字节),兼容部规与扩展规约
        }
        switch(obj_buff[3])
        {
        case 1:             //自动循环显示
            data_len = PAR_LOOPDIS1_04040101_00_LEN+1;      //加1字节的扩展小标识DIx
            file_write((PAR_LOOPDIS1_04040101_00_ADDR + (obj_buff[2] - 1) * data_len), obj_buff + 14, data_len);
#ifdef LCD_VALID
            set_dis_para_flag(2);
            lcd_init(1);
#endif
            break;
        case 2:             //按键循环显示
            data_len = PAR_KEYDIS1_04040201_00_LEN+1;
            file_write((PAR_KEYDIS1_04040201_00_ADDR + (obj_buff[2] - 1) * data_len ), obj_buff + 14, data_len);
#ifdef LCD_VALID
            set_dis_para_flag(4);
            lcd_init(1);
#endif            
            break;
        default:
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        return 0;
    }

    index = compare_total_id(obj_buff + 2, parameter_frm[0], 3, PAR_FRM_NUM);            //除时区、段、假表以外的参变量表标识码判断

    while(1)
    {
        t_buf = alloc_comm_mem(MEM_256_TYPE, &mem_type, GET_MEM_ERR12);
        if(t_buf!=NULL)
        {
            break;
        }
        else
        {
//          memcpy(gusCurMemErrFunName, "write_pa", 8);
            setmemgetnullid(GET_MEM_ERR12, gusCurMemErrFunName);
        }
        os_dly_wait(2);
    }

    if(index ==0xff)
    {
            i = compare_total_id(obj_buff + 3, time_table_frm[0], 2, 3);        //为时区、段、假表标识参照表返回下标
            if(i == 0xff)
            {
                tmp = ((U16)obj_buff[4] << 8) + obj_buff[3];                    //标识码ID2,ID1组合,密码修改为0x000c
                if((tmp != 0x0C) || (obj_buff[2] > 0x0a ) || (obj_buff[2] == 0))
                {
                    len = deal_with_err_frame(rev_buff, 1);
                    free_mem_block(t_buf);//Mem_256_Byte
                    return len;
                }
                else                                                            //修改密码的
                {
                    if((obj_buff[2] != (obj_buff[14] + 1)) || (obj_buff[1] != 16))  //标识码无法与要修改的权限对应或数据长度不对
                    {
                        len = deal_with_err_frame(rev_buff, 1);                 //返回其他错误
                        free_mem_block(t_buf);//Mem_256_Byte
                        return len;
                    }
                    else
                    {
                        if(pswd < (11 - obj_buff[2]))                           //密码权限不足
                        {
                            len = deal_with_err_frame(rev_buff, 4);
                            free_mem_block(t_buf);//Mem_256_Byte
                            return len;
                        }
                        else
                        {
                             file_write(PAR_PRI0PSWD_04000C01_00_ADDR + 4 * obj_buff[14], obj_buff + 14, 4);
                             len = 0;
                        }
                    }
                }
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
                prg_record_state = OTHER_RECORD;                                //其他编程
#endif
            }
            else                                                                //时区表、时段表、公共假日表修改
            {
                if(pswd < password_popedom[i + 49])                             //密码权限不足
                {
                    len = deal_with_err_frame(rev_buff, 4);
                    free_mem_block (t_buf);//Mem_256_Byte
                    return len;
                }
                data_len = (time_table_frm[i][0] >> 16);
                if(obj_buff[1] != (data_len + 12))
                {
                    len = deal_with_err_frame(rev_buff, 1);
                    free_mem_block(t_buf);//Mem_256_Byte
                    return len;
                }
                if(obj_buff[2] > (time_table_frm[i][0] >> 24) || ((obj_buff[2] == 0) && (i == 2)))
                {
                    len = deal_with_err_frame(rev_buff, 2);
                    free_mem_block(t_buf);//Mem_256_Byte
                    return len;
                }
                //memcpy((U8 *)&Sys_Mem[4] + 6, obj_buff + 10, 4);        //提取操作者代码
                memcpy(t_buf + 6, obj_buff + 10, 4);        //提取操作者代码
                if(obj_buff[2] == 0)
                {
#if CODE_VER_TYPE==H_METER_PRJ				//配合高压表
                    if(prg_record_state != ZONE_RECORD)                 //上一次编程非时区表编程
                    {
                        //azh 110527
                        record_zone_program_event(t_buf);    //时区表编程记录
                        prg_record_state = ZONE_RECORD;
                    }
#endif
                }
                else if(i < 2)
                {
#if CODE_VER_TYPE==H_METER_PRJ				//配合高压表
                    if(prg_record_state != TIME_RECORD)                 //上一次编程非时段表编程
                    {
                        record_table_program_event(t_buf);   //时段表编程记录
                        prg_record_state = TIME_RECORD;
                    }
#endif

                }
                else if(i == 2)
                {
#if CODE_VER_TYPE==H_METER_PRJ				//配合高压表
                    if(prg_record_state != HOLIDAY_RECORD)              //上一次编程非假日表编程
                    {
                        record_holiday_program_event(t_buf);//假日表编程记录
                        prg_record_state = HOLIDAY_RECORD;
                    }
#endif
                }

                file_write(time_table_frm[i][1] + (U8)(time_table_frm[i][0] >> 16) * obj_buff[2], obj_buff + 14, data_len);
//                deal_fee_table(1);                                      //强制判断当前费率号
            }
    }
    else
    {
        if(pswd < password_popedom[index])                              //密码权限不足
        {
            len = deal_with_err_frame(rev_buff, 4);
            free_mem_block(t_buf);//Mem_256_Byte
            return len;
        }
        data_len = (parameter_frm[index][0] >> 24);                     //修改的参数长度
        if(obj_buff[1] != (data_len + 12))                              //数据长度错
        {
            len = deal_with_err_frame(rev_buff, 1);
            free_mem_block(t_buf);//Mem_256_Byte
            return len;
        }
        switch(index)
        {
#if CODE_VER_TYPE==GPRS_MODULE_PRJ		//配合带CPU_GPRS模块
        case 9:                             //通信地址                      9
        case 10:                            //表号                          10
        case 11:                            //资产管理编码(ASCII)           11
            file_write(parameter_frm[index][1], obj_buff + 14, data_len);
            break;
#else
//azh
//        case 0:                             //最大需量周期（分钟）  0
//        case 1:                             //滑差时间（分钟）      1
//        case 2:                             //两套时区表切换时间（年月日时分）  2
//        case 3:                             //两套日时段表切换时间（年月日时分）3
//        case 4:                             //年时区数p≤14                 4
//        case 5:                             //日时段表数q≤8                5
//        case 6:                             //日时段数(每日切换数) m≤14    6
//        case 7:                             //费率数k≤63                   7
//        case 8:                             //公共假日数n≤254              8
        case 9:                             //通信地址                      9
        case 10:                            //表号                          10
        case 11:                            //资产管理编码(ASCII)           11
//        case 12:                            //周休日状态字                  12
//        case 17:                            //负荷记录模式字                17
//        case 18:                            //冻结数据模式字                18
//        case 19:                            //负荷记录起始时间（月日时分）  19
//        case 20:                            //第1类负荷记录间隔时间（分钟） 20
//        case 21:                            //第2类负荷记录间隔时间（分钟） 21
//        case 22:                            //第3类负荷记录间隔时间（分钟） 22
//        case 23:                            //第4类负荷记录间隔时间（分钟） 23
//        case 24:                            //第5类负荷记录间隔时间（分钟） 24
//        case 25:                            //第6类负荷记录间隔时间（分钟） 25
//        case 29:                            //正向有功功率上限              29
//        case 30:                            //反向有功功率上限              30
//        case 31:                            //电压上限值                    31
//        case 32:                            //电压下限值                    32
            file_write(parameter_frm[index][1], obj_buff + 14, data_len);
            break;
//        case 26:
//        case 27:
//        case 28:                                    //结算日编程记录
//            memcpy(t_buf + 6, obj_buff + 10, 4);    //提取操作者代码
//            record_account_day_program_event(t_buf);
//            file_write(parameter_frm[index][1], obj_buff + 14, data_len);
//            break;
//        case 13:                            //周休日执行时段表号            13
//        case 14:                            //有功组合方式特征字            14
//        case 15:                            //无功组合方式1特征字           15
//        case 16:                            //无功组合方式2特征字           16
//            memcpy(t_buf + 6, obj_buff + 10, 5);    //提取操作者代码和数据，下面的函数是周休日、组合字等编程记录
////             record_weekday_program_event(t_buf, event_count_addr[index - 7]); //本函数调用时注意event_count_addr[]和parameter_frm[][1]的配合
//            file_write(parameter_frm[index][1], obj_buff + 14, data_len);
//            break;
#endif
        case 33:                            //时间
//            get_on_chip_time(t_buf + 4);          //读取当前时间给校时记录使用
            err = set_sys_time(obj_buff + 14);      //修改时间
            if(err != 1)                            //修改失败，返回其他错误
            {
                len = deal_with_err_frame(rev_buff, 1);
                free_mem_block(t_buf);//Mem_256_Byte
                return len;
            }
            memcpy(t_buf, obj_buff + 10, 4);        //提取操作者代码
//            record_check_time_event(t_buf);       //记录校时记录
            break;
        case 34:                                    //日期和星期
//            get_on_chip_time(t_buf + 4);            //读取当前时间给校时记录使用
            err = set_sys_date(obj_buff + 14);      //修改日期
            if(err != 1)                            //修改失败，返回其他错误
            {
                len = deal_with_err_frame(rev_buff, 1);
                free_mem_block(t_buf);//Mem_256_Byte
                return len;
            }
            memcpy(t_buf, obj_buff + 10, 4);         //提取操作者代码
//            record_check_time_event(t_buf);         //记录校时记录
            break;
        case 57:                                    //自动循环显示屏数
            file_write(parameter_frm[index][1], obj_buff + 14, data_len);
#ifdef LCD_VALID
            set_dis_para_flag(0);
            lcd_init(1);
#endif
            break;
        case 58:                                    //每屏显示时间
            file_write(parameter_frm[index][1], obj_buff + 14, data_len);
#ifdef LCD_VALID
            set_dis_para_flag(1);
            lcd_init(1);
#endif
            break;
        case 61:                                    //按键循环显示屏数
            file_write(parameter_frm[index][1], obj_buff + 14, data_len);
#ifdef LCD_VALID
            set_dis_para_flag(3);
            lcd_init(1);
#endif
            break;
        default:
            len = deal_with_err_frame(rev_buff, 1);
            free_mem_block(t_buf);//Mem_256_Byte
            return len;
        }
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
        prg_record_state = OTHER_RECORD;            //其他编程
#endif        
    }
    memcpy(t_buf + 8, obj_buff + 10, 4);            //提取操作者代码
    memcpy(t_buf, obj_buff + 2, 4);                 //提取标识码

    after_fram_flag = 0;                            //无后续帧
    free_mem_block(t_buf);//Mem_256_Byte
    return 0;                                       //写数据正常返回的数据域长度为0
}
/******************************************************************************
** 函数名称: S32 deal_with_freeze_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 解析冻结数据标识帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**           码开始，已加0x33。
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: obj_buff[2]: ID0,上几次的冻结记录
**           obj_buff[3]: ID1,冻结数据的小类
**           obj_buff[4]: ID2 冻结数据的大类，0定时、1瞬时、2时区切换、3日时段切换
**           obj_buff[5]: ID3,冻结类型应为05
******************************************************************************/
S32 deal_with_freeze_frame (U8 *obj_buff, U8 *rev_buff)
{
    U8 i;
    U8 total;
    U8 point;
    U8 data_len;
    U8 freeze_state_word;                   //冻结状态字
    U16 total_data_len;
    U16 addr_offset;
    U32 point_addr;                         //需要读取冻结类型(obj_buff[4])的当前指针地址
    U32 aim_addr;
    S32 len;

    total_data_len = 0;
    after_fram_flag = 0;
    if((obj_buff[4] > 3) || (obj_buff[2] > 12) || (obj_buff[2] == 0))                           //标识码错
    {
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }
    if(((obj_buff[4] > 0) && (obj_buff[2] > 3)) || ((obj_buff[4] > 1) && (obj_buff[2] > 2)))    //标识码错误
    {
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }

    file_read(PAR_FREEZEMD_04000902_00_ADDR, (U8 *)&freeze_state_word, 1);            //读冻结状态字
    switch(obj_buff[4])
    {
    case 0:                                             //定时冻结
        total = 12;                                     //12次
        point_addr = TIMING_FREEZE_DATA_POINTER;        //定时冻结数据当前的指针地址
        break;
    case 1:                                             //瞬时冻结
        total = 3;                                      //3次
        point_addr = INSTANT_FREEZE_DATA_POINTER;       //瞬时冻结数据当前的指针地址
        break;
    case 2:                                             //时区切换
        total = 2;                                      //2次
        point_addr = ZONE_CHANGE_FREEZE_DATA_POINTER;   //定时冻结数据当前的指针地址
        break;
    case 3:                                             //日时段切换
        total = 2;                                      //2次
        point_addr = TIME_CHANGE_FREEZE_DATA_POINTER;   //定时冻结数据当前的指针地址
        break;
    default:                                            //标识码错
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }
    file_read(point_addr, (U8 *)&point, 1);                         //读出当前指针
    point = decrease_event_record_point(point, total, obj_buff[2]); //追溯请求数据的偏移指针
    if(__FAIL == (S8)point)                                         //返回指针错误
    {
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }
    else
    {
        point &= 0x7f;                              //最高位为翻滚记录，屏蔽
    }
    switch(obj_buff[3])                             //0到10代表的意义可见freeze_offset_addr[11][2]定义右方的说明
    {
    case 0 :                                        //冻结的时间
        data_len = 5;
        addr_offset = point * SINGLE_FREEZE_STORE_LEN;
        file_read(freeze_type_addr[obj_buff[4]] + addr_offset, rev_buff + 4, data_len);
        break;
    case 1 :                                        //正向有功电能
    case 2 :                                        //反向有功电能
    case 3 :                                        //组合无功电能1
    case 4 :                                        //组合无功电能2
    case 5 :                                        //第一象限无功电能
    case 6 :                                        //第二象限无功电能
    case 7 :                                        //第三象限无功电能
    case 8 :                                        //第四象限无功电能
    case 9 :                                        //有功需量
    case 10 :                                       //无功需量
        if((freeze_state_word & freeze_state_table[obj_buff[3]]) == 0)   //判断请求冻结数据是否有效
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        else
        {
            addr_offset = freeze_offset_addr[obj_buff[3]][0] + point * SINGLE_FREEZE_STORE_LEN;
            data_len = freeze_offset_addr[obj_buff[3]][1];
            file_read(freeze_type_addr[obj_buff[4]] + addr_offset, rev_buff + 4, data_len);
        }
        break;
    case 0x10:                                      //瞬时变量
        if((freeze_state_word & 0x80) == 0)
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        else
        {
            addr_offset = freeze_offset_addr[11][0] + point * SINGLE_FREEZE_STORE_LEN;
            data_len = freeze_offset_addr[11][1];
            file_read(freeze_type_addr[obj_buff[4]] + addr_offset, rev_buff + 4, data_len);
        }
        break;
    case 0xff:                                     //某一次冻结数据块
        aim_addr = freeze_type_addr[obj_buff[4]] + point * SINGLE_FREEZE_STORE_LEN; //某一类某一次的冻结数据块首地址
        total_data_len = freeze_offset_addr[0][1];          //冻结时间长度 5个字节
        file_read(aim_addr, rev_buff + 4, total_data_len);  //填充冻结时间
        for(i = 1; i < 12; i++)
        {
            if((freeze_state_word & freeze_state_table[i]) != 0)    //参照冻结状态字判断该项是否有效冻结数据
            {
                addr_offset = freeze_offset_addr[i][0];
                data_len = freeze_offset_addr[i][1];
                file_read(aim_addr + addr_offset, rev_buff + 4 + total_data_len, data_len);
                total_data_len += data_len;
                if(total_data_len > MAX_DATA_LEN)                   //超过最大帧长，需要后续帧
                {
                    total_data_len -= data_len;
                    after_fram_flag = 1;                //返回功能码需要带后续帧标识

                    After_Frame[1].State = 1;              //后续帧有效标识
                    After_Frame[1].State_Word_Bit = i;
                    After_Frame[1].Current_Seq = 1;
                    After_Frame[1].Spare_Len = 0;
                    After_Frame[1].Tick = OS_Time;//Sys_Tick;
                    After_Frame[1].Id[0] = obj_buff[2];
                    After_Frame[1].Id[1] = obj_buff[3];
                    After_Frame[1].Id[2] = obj_buff[4];
                    After_Frame[1].Id[3] = obj_buff[5];
                    After_Frame[1].Address = aim_addr;
                    break;
                }
            }
        }
        data_len = total_data_len;
        break;
    default:
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }
    for(i = 0; i < 4; i++)
    {
        rev_buff[i] = obj_buff[i + 2];
    }
    len = 4 + data_len;
    for(i = 0; i < len; i++)
    {
        rev_buff[i] += 0x33;
    }
    return len;
}

/******************************************************************************
** 函数名称: U32 check_freeze_time_valid (U8 *time)
** 函数功能: 判断冻结命令发送的时间（BCD码）是否有效
** 入口参数: time: 冻结时间地址，分+时+日+月
** 返 回 值: __TRUE时间有效，__FALSE时间无效
** 说    明: 因为此函数的作用是判断定时冻结的时间是否有效，所以瞬时冻结是无效的
******************************************************************************/
/*
U32 check_freeze_time_valid (U8 *time)
{
    U8 temp, i;
    U8 day;
    for(i = 0; i <4; i++)
    {
        if(((time[i] & 0x0f) > 9) || ((time[i] & 0xf0) > 0x90))
        {
            return __FALSE;
        }
    }

    if(time[0] > 0x59)
    {
        return __FALSE;
    }

    if(time[3] != 0x99)                                 //MMDDhhmm定时冻结以年为周期冻结
    {
        if((time[3] > 0x12) || (time[3] == 0))          //月
        {
            return __FALSE;
        }
        temp = (time[3] >> 4) * 10 + (time[3] & 0x0f);
        temp = last_day_of_month(0x16, temp);
        day = (time[2] >> 4) * 10 + (time[2] & 0x0f);
        if(temp < day)
        {
            return __FALSE;
        }
        if(time[1] > 0x23)                              //时
        {
            return __FALSE;
        }
    }
    else
    {
        if(time[2] != 0x99)                             //99DDhhmm定时冻结以月为周期冻结
        {
            if((time[2] > 0x31) || (time[2] == 0))
            {
                return __FALSE;
            }
            if(time[1] > 0x23)
            {
                return __FALSE;
            }
        }
        else
        {
            if(time[1] != 0x99)                         //成立9999hhmm,不成立999999mm定时冻结以日为周期冻结
            {
                if(time[1] > 0x23)
                {
                    return __FALSE;
                }
            }
        }
    }

    return __TRUE;
}
*/
/******************************************************************************
** 函数名称: S32 deal_with_after_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 解析后续帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: 06
******************************************************************************/
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
S32 deal_with_after_frame (U8 *obj_buff, U8 *rev_buff)
{
    U8 i;
    U8 data_len;
    U8 total_data_len;
    U8 freeze_state_word;
    U32 aim_addr;
    S32 len;

    data_len = 0;
    total_data_len = 0;
    after_fram_flag = 0;
    if(obj_buff[1] != 5)
    {
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }

//--------------------事件记录的后续帧处理----------------------------------
    if(obj_buff[5] == 0x03)
    {
        for(i = 0; i < 4; i++)
        {
            if(obj_buff[2 + i] != After_Frame[0].Id[i])
            {
                len = deal_with_err_frame(rev_buff, 2);
                return len;
            }
        }
        if(obj_buff[6] != After_Frame[0].Current_Seq)               //判断后续帧帧号
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        if(After_Frame[0].State == 0)
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        if(After_Frame[0].Spare_Len > MAX_DATA_LEN)                 //还有后续帧
        {
            after_fram_flag = 1;
            data_len = MAX_DATA_LEN;
            aim_addr = After_Frame[0].Address;
            rev_buff[4 + data_len] = After_Frame[0].Current_Seq;

            After_Frame[0].State = 1;
            After_Frame[0].Spare_Len -= MAX_DATA_LEN;
            After_Frame[0].Address += MAX_DATA_LEN;
            After_Frame[0].Tick = OS_Time;//Sys_Tick;
            After_Frame[0].Current_Seq++;
        }
        else
        {
            after_fram_flag = 0;
            data_len = After_Frame[0].Spare_Len;
            aim_addr = After_Frame[0].Address;
            rev_buff[4 + data_len] = After_Frame[0].Current_Seq;    //填充后续帧帧号

            After_Frame[0].State = 0;                               //清除后续帧有效标识
        }

        file_read(aim_addr, rev_buff + 4, data_len);                //填充后续帧的数据
    }
//--------------------冻结数据后续帧-----------------------------------
    else if(obj_buff[5] == 0x05)
    {
        for(i = 0; i < 4; i++)
        {
            if(obj_buff[2 + i] != After_Frame[1].Id[i])
            {
                len = deal_with_err_frame(rev_buff, 2);
                return len;
            }
        }
        if(obj_buff[6] != After_Frame[1].Current_Seq)               //判断后续帧帧号
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        if(After_Frame[1].State == 0)
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        after_fram_flag = 0;
        After_Frame[1].State = 0;                                   //清除后续帧有效标识
        file_read(PAR_FREEZEMD_04000902_00_ADDR, (U8 *)&freeze_state_word, 1);
        for(i = After_Frame[1].State_Word_Bit; i < 12; i++)         //冻结数据一共12项，读取剩余项
        {
            if((freeze_state_word & freeze_state_table[i]) != 0)    //参照冻结状态字判断该项是否有效冻结数据
            {
                data_len = freeze_offset_addr[i][1];
                file_read(After_Frame[1].Address + freeze_offset_addr[i][0], rev_buff + 4 + total_data_len, data_len);
                total_data_len += data_len;
            }
        }
        data_len = total_data_len;
        rev_buff[4 + data_len] = After_Frame[1].Current_Seq;
    }
    for(i = 0; i < 4; i++)
    {
        rev_buff[i] = obj_buff[i + 2];
    }
    len = 5 + data_len;
    for(i = 0; i < len; i++)
    {
        rev_buff[i] += 0x33;
    }
    return len;

}
#endif//#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		
/******************************************************************************
** 函数名称: S32 deal_with_err_frame(U8 *rev_buff, U8 flag)
** 函数功能: 处理错误的数据标识帧
** 入口参数: U8 *rev_buff: 存放返回错误信息状态字的数组。
**           U8 flag:      错误字信息
**              1、0x40:   费率数超
**              2、0x20:   日时段数超
**              3、0x10:   年时段数超
**              4、0x08:   通信速率不能更改
**              5、0x04：  密码错无授权
**              6、0x02:   无请求数据
**              7、0x01:   其他错误
** 返 回 值: -1: 表示为错误信息帧，需要启用异常应答
** 说    明:    除了前6种可能的情况，其他的一律按0x01处理。
******************************************************************************/
S32 deal_with_err_frame (U8 *rev_buff, U8 flag)
{
    switch(flag)
    {
    case 0x02:
        rev_buff[0] = 0x02 + 0x33;
        break;
    case 0x04:
        rev_buff[0] = 0x04 + 0x33;
        break;
    case 0x08:
        rev_buff[0] = 0x08 + 0x33;
        break;
    case 0x10:
        rev_buff[0] = 0x10 + 0x33;
        break;
    case 0x20:
        rev_buff[0] = 0x20 + 0x33;
        break;
    case 0x40:
        rev_buff[0] = 0x40 + 0x33;
        break;
    default:
        rev_buff[0] = 0x01 + 0x33;
        break;
    }
    after_fram_flag = 0;
    return -1;
}

/******************************************************************************
** 函数名称: U8 check_radio_time_valid(U8 *time)
** 函数功能: 判断广播校时的格式是否有效
** 入口参数: time: BCD时间地址，秒+分+时+日+月+年
** 返 回 值: __TRUE时间格式有效，__FALSE时间格式无效
** 说    明: 无
******************************************************************************/
U8 check_radio_time_valid (U8 *time)
{
    U8 i;

    for(i = 0; i < 6; i++)
    {
        if(((time[i] & 0x0f) > 9) || ((time[i] & 0xf0) > 0x90))
        {
            return __FALSE;
        }
    }
    if(time[0] > 0x59)                          //秒
    {
        return __FALSE;
    }
    if(time[1] > 0x59)                          //分
    {
        return __FALSE;
    }
    if(time[2] > 0x23)                          //时
    {
        return __FALSE;
    }
    if((time[3] == 0) || (time[3] > 0x31))      //日
    {
        return __FALSE;
    }
    if((time[4] == 0) || (time[4] > 0x12))      //月
    {
        return __FALSE;
    }
    if((time[5] < 0x10) || (time[5] > 0x50))    //年，在2010~2050之间
    {
        return __FALSE;
    }
    return __TRUE;
}

/******************************************************************************
** 函数名称: S32 read_register_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 读取内部寄存器数据。
** 入口参数: obj_buff[0]-功能码,obj_buff[2..5]-标识，
**           obj_buff[6][7]-厂家内部标识，内部，读内部寄存器应该为0x0100,
**           obj_buff[8..11]-寄存器地址，obj_buff[12]长度
** 返 回 值: rev_buff[0..3]标识码，rev_buff[4..9]厂家标识+寄存器地址rev_buff[10..]数据
** 说    明: 无
******************************************************************************/
/*
S32 read_register_frame (U8 *obj_buff, U8 *rev_buff)
{
    U8 i;
    S32 err, len;
    U32 address;

    if(obj_buff[1] == 11)       //长度11,0x000001标识码
    {
        address = obj_buff[8] + ((U32)obj_buff[9] << 8) + ((U32)obj_buff[10] << 16) +((U32)obj_buff[11] << 24);
        err = file_read(address, rev_buff + 10, obj_buff[12]);
        if(err == 1)
        {
            for(i = 0; i < 10; i++)
            {
                rev_buff[i] = obj_buff[2 + i];
            }
            len = 10 + obj_buff[12];
            for(i = 0; i < len; i++)
            {
                rev_buff[i] += 0x33;
            }
        }
        else
        {
            rev_buff[0] = err + 0x33;
            return -1;
        }
    }
    else
    {
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }
    return len;
}
*/
/******************************************************************************
** 函数名称: S32 write_register_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 写内部寄存器数据。
** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度,obj_buff[2..5]-标识，obj_buff[16..19]-需要写的起始地址，
**           obj_buff[20]需要写的数据长度，obj_buff[21...]需要写的数据，
** 返 回 值: 无
** 说    明: 无
******************************************************************************/
/*
S32 write_register_frame (U8 *obj_buff, U8 *rev_buff, U8 pswd)
{
    S32 err, len;
    U32 address;

    if(pswd < 11)                               //超级密码级别
    {
        len = deal_with_err_frame(rev_buff, 4);
        return len;
    }

    address = obj_buff[16] + ((U32)obj_buff[17] << 8) + ((U32)obj_buff[18] << 16) +((U32)obj_buff[19] << 24);
    err = file_write(address, obj_buff + 21, obj_buff[20]);
    if(err == 1)
    {
        return 0;
    }
    else if(err == -2)
    {
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }
    else
    {
        len = deal_with_err_frame(rev_buff, 1);
        return len;
    }
}
*/
/******************************************************************************
** 函数名称: U8 check_password(U8 *obj_buff)
** 函数功能: 检查密码权限
** 入口参数: obj_buff[0..3]-密码
** 返 回 值: 12超级跳线，11超级密码，10...1对应0...9级密码权限，
** 说    明: 返回的数值越大，权限越高，目前12为最高权限。返回0表示密码错误或者处于非编程状态
******************************************************************************/
U8 check_password (U8 *obj_buff)
{
    U32 tmp;
    U32 password_tmp;

//    if(PORT0_IS_HIGH(P0_KEYPRG) == 0)           //跳线短上
//    {
//        return 12;
//    }
    tmp = obj_buff[0] + ((U32)obj_buff[1] << 8) + ((U32)obj_buff[2] << 16) + ((U32)obj_buff[3] << 24);
    if(SUPER_PASSWORD == tmp)                   //超级密码
    {
        return 11;
    }
    //if((gMeter_State[2] & 0x08) && (obj_buff[0] < 10)) //若在编程状态
    if((__TRUE == prog_key_enable()) && (obj_buff[0] < 10)) //若在编程状态
    {
        file_read(PAR_PRI0PSWD_04000C01_00_ADDR + PAR_PRI0PSWD_04000C01_00_LEN * obj_buff[0], (U8 *)&password_tmp, PAR_PRI0PSWD_04000C01_00_LEN);
//        if(password_tmp == (tmp >> 8))
        if(password_tmp == tmp)
        {
            return (10 -obj_buff[0]);
        }
    }
    return 0;
}
/******************************************************************************
** 函数名称: void short_link_check(void)
** 函数功能: 检测超级跳线，短路时，编程状态字位置1。
** 入口参数: 无
** 返 回 值: 无
** 说    明: 检测到跳线短路时进入编程状态，断开时编程时间超了退出编程状态
******************************************************************************/
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
void short_link_check (void)
{
    SET_PORT0_IN(P0_KEYPRG);                    //配置p1.0为输入口

    if(PORT0_IS_HIGH(P0_KEYPRG) == 0)           //跳线短上
    {
        gMeter_State[2] |= 0x08;           //编程状态位置位
//      prg_en_tick = Sys_Tick;                 //超级跳线去掉后，编程状态会保持PRG_EN_DLY_TIME时间退出
        prg_en_tick = OS_Time;                  //记录按下编程按键的时标
    }
    else if(gMeter_State[2] & 0x08)
    {
        //if((Sys_Tick - prg_en_tick) >  prg_en_time)     //时间超了
        //azh 110527
        if((OS_Time - prg_en_tick) >  prg_en_time)     //时间超了
        {
            gMeter_State[2] &= 0xf7;
//azh 110527
//            Sys_Mem[4][0] = 1;
//            append_program_record((U8 *)&Sys_Mem[4]);   //记录退出编程按键前的编程记录
            prg_record_state = NO_RECORD;               //把编程记录状态清掉
        }
    }
}
#endif
/******************************************************************************
** 函数名称: S32 set_password (U8 *obj_buff, U8 *rev_buff)
** 函数功能: 修改密码
** 入口参数: obj_buff[1]长度,obj_buff[6..9]权限密码,obj_buff[10..13]需要设的密码
**           rev_buff[]返回数组存放位置
** 返 回 值:  -1:异常应答处理，其他数据域长度
** 说    明: 此帧的标识码无用，不需判断
******************************************************************************/
S32 set_password (U8 *obj_buff, U8 *rev_buff)
{
    S8 tmp;
    U8 i;

    if((obj_buff[1] != 0x0c)||(obj_buff[10] > 10))  //长度出错或者需要修改的密码权限错误
    {
        deal_with_err_frame(rev_buff, 1);
        return -1;
    }

    tmp = check_password(obj_buff + 6);             //检查权限，10到1对应0到9级密码权限.
    tmp = tmp + obj_buff[10] - 10;                  //比较授权权限

    if(tmp < 0)
    {
        deal_with_err_frame(rev_buff, 4);           //密码错未授权
        return -1;
    }

    //file_write(PASSWORD_ADDR + SINGLE_PASSWORD_LEN * obj_buff[10], obj_buff + 11, 3);//修改对应的密码
    file_write(PAR_PRI0PSWD_04000C01_00_ADDR + PAR_PRI0PSWD_04000C01_00_LEN * obj_buff[10], obj_buff + 10, PAR_PRI0PSWD_04000C01_00_LEN);//修改对应的密码

    for(i = 0; i < 4; i++)                          //填充返回数据域
    {
        rev_buff[i] = obj_buff[10 + i] + 0x33;
    }
    return 4;                                       //返回数据域长度
}

/******************************************************************************
** 函数名称: S32 set_produce_para(U8 *obj_buff, U8 *rev_buff, pswd)
** 函数功能: 设置厂家参数：电能底度、厂家资料
** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度,obj_buff[2..5]-标识，
             obj_buff[6...13]密码和操作者代码，obj_buff[][15]厂家指令大类
**           obj_buff[14]厂家指令小类，obj_buff[16...]需要写的数据，
** 返 回 值: 无
** 说    明: 无
******************************************************************************/

//S32 set_produce_para(U8 *obj_buff, U8 *rev_buff, U8 pswd)
//{
//    U8 data_len;
//    U16 crc_16;
//    S32 len;
//
//    if(pswd < 11)                               //超级密码级别
//    {
//        len = deal_with_err_frame(rev_buff, 4);         //未授权
//        return len;
//    }
//
//    if(obj_buff[14] > 0x1c)//标识码错误
//    {
//        len = deal_with_err_frame(rev_buff, 2);
//        return len;
//    }
//
//    data_len = 4 + 4 + 4 + 2 + produce_set_num[obj_buff[14]];
//    if(data_len != obj_buff[1])                         //设置的参数的长度判断
//    {
//        len = deal_with_err_frame(rev_buff, 1);
//        return len;
//    }
//
//    file_write(produce_set_addr[obj_buff[14]], obj_buff + 16, produce_set_num[obj_buff[14]]);
//    if(obj_buff[14] < 0x10)
//    {
//        crc_16 = calc_crc16(obj_buff + 16, produce_set_num[obj_buff[14]], 0xffff);
//        file_write(produce_set_addr[obj_buff[14]] + produce_set_num[obj_buff[14]], (U8 *)&crc_16, 2);
//    }
//    return 0;
// }

/******************************************************************************
** 函数名称: S32 deal_program_enable(U8 *obj_buff, U8 *rev_buff, U8 pswd)
** 函数功能: 打开编程状态
** 入口参数: ** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度，
             obj_buff[15]厂家指令大类 ,obj_buff[14]厂家指令小类，
**           obj_buff[16]需要打开的分钟数，
** 返 回 值: 长度
** 说    明: [1] = 18,[14] = 0x03,[15] = 0,obj_buff[16]打开分钟数
******************************************************************************/
S32 deal_program_enable(U8 *obj_buff, U8 *rev_buff, U8 pswd)
{
    U32 tmp;
    S32 len;

    tmp = obj_buff[14]  + ((U32)obj_buff[1] << 8);
    if(0x0f00 == tmp)
    {
        obj_buff[16] = (obj_buff[16] >> 4) * 10 + (obj_buff[16] & 0x0f);
        if((obj_buff[16] != 0) && (pswd < 11))
        {
            len = deal_with_err_frame(rev_buff, 4);     //未授权
            return len;
        }
        prg_en_time = obj_buff[16] * OS_DLY_60S;//DLY_1MIN;
        gMeter_State[2] |= 0x08;               //编程状态位置位
        prg_en_tick = OS_Time;//Sys_Tick;                     //超级跳线去掉后，编程状态会保持PRG_EN_DLY_TIME时间退出
        return 0;
    }
    else
    {
        len = deal_with_err_frame(rev_buff, 2);     //无请求数据
        return len;
    }

}
/******************************************************************************
** 函数名称: S32 read_produce_frame(U8 *obj_buff, U8 *rev_buff)
** 函数功能: 读取厂家扩充指令内容
** 入口参数: obj_buff[0]-功能码,obj_buff[2..5]-标识，
**           obj_buff[6][7]-厂家内部标识，
** 返 回 值: len：-1表示异常帧，其他表示数据域长度rev_buff[0..3]标识码，rev_buff[4][5]厂家标识,rev_buff[6...]数据
** 说    明: 无
******************************************************************************/
// S32 read_produce_frame (U8 *obj_buff, U8 *rev_buff)
// {
//     S32 len=0;

//     switch(obj_buff[7])
//     {
//     case 0:
// //        len = deal_with_calib_frame(obj_buff, rev_buff, 12, index);    //读取校准参数
//         break;
//     case 1:
// //        len = read_register_frame(obj_buff, rev_buff);          //读取内部寄存器
//         break;
//     case 4:
// //        len = deal_with_upgrade_frame(obj_buff, rev_buff, 0, index);
//         break;
//     case 5:
// //        len = read_information_frame(obj_buff, rev_buff);       //读取当前信息
//         break;
//     case 6:
// //        len = read_online_calib_frame(obj_buff, rev_buff, index);   //读校核数据
//         break;
//     case 7:
// //        len = deal_with_outside_transfer_a(obj_buff, rev_buff, 0, index); //透传
//         break;
//     case 9:
//         len = deal_with_display_terminal_frame(obj_buff, rev_buff, 0); //显示终端扩充
//         break;
//     default:
//         len = deal_with_err_frame(rev_buff, 2);                 //标识码错，无请求数据
//         break;
//     }
//     return len;
// }

/******************************************************************************
** 函数名称: S32 write_produce_frame(U8 *obj_buff, U8 *rev_buf, fU8 pswd, U8 index)
** 函数功能: 厂家扩充的写指令。
** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度,obj_buff[2..5]-标识，obj_buff[16..19]-需要写的起始地址，
**           obj_buff[20]需要写的数据长度，obj_buff[21...]需要写的数据，
             pswd:为密码权限，index 为内存块下标
** 返 回 值: -1表示异常帧，其他表示数据域长度
** 说    明: 无
******************************************************************************/
//S32 write_produce_frame (U8 *obj_buff, U8 *rev_buff, U8 pswd, U8 index)
S32 write_produce_frame (U8 *obj_buff, U8 *rev_buff, U8 pswd)
{
//    U8 index=0;
    S32 len=0;

    switch(obj_buff[15])
    {
    case 0:
//        len = deal_with_calib_frame(obj_buff, rev_buff, pswd, index);   //写校准参数
        break;
    case 1:
//        len = write_register_frame(obj_buff, rev_buff, pswd);           //写内部寄存器
        break;
    case 2:
//        len = set_produce_para(obj_buff, rev_buff, pswd);               //设置底度和厂家信息
        break;
    case 3:
        len = deal_program_enable(obj_buff, rev_buff, pswd);            //打开编程状态
        break;
    case 4:
//        len = deal_with_upgrade_frame(obj_buff, rev_buff, pswd, index); //远程升级
        break;
/*
    case 5:                                                             //AD切换通道
        if(pswd < 11)                                                   //密码权限
        {
            len = deal_with_err_frame(rev_buff, 8);
            return len;
        }
        else
        {

            if(((Sys_Share_Reg >> SYS_SHARE_REG_BIT_AD_CALI) ^ obj_buff[16]) & 0x1)
            {
                Sys_Share_Reg ^= (1 << SYS_SHARE_REG_BIT_AD_CALI);
            }

            return 0;
        }
    case 6:
        len = start_online_calib_frame(obj_buff, rev_buff, pswd, index);
        break;
    case 7:
        len = deal_with_outside_transfer_a(obj_buff, rev_buff, pswd, index);
        break;
*/
    default:
        len = deal_with_err_frame(rev_buff, 2);                     //标识码错，无请求数据
        break;
    }

    return len;
}

/******************************************************************************
** 函数名称: S32 deal_with_online_calib_frame(U8 *obj_buff, U8 *rev_buff, U8 index)
** 函数功能: 读在线校准数据
** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度,obj_buff[2..5]-标识
**           obj_buff[6][7]-厂家内部标识,obj_buff[8][9]帧号
**           rev_buff：返回数据的地址，按DLT645规约返回的数据域格式
** 返 回 值: 其他表示数据域长度
             -1表示异常帧，长度为1，填入rev_buff[0]：0x3B表示密码错
             0x28表示校核未完成
             0x26表示校核数据正在外发
             0x25表示帧号错误
** 说    明: 无
******************************************************************************/
/*
S32 read_online_calib_frame(U8 *obj_buff, U8 *rev_buff, U8 index)
{
    U32 i;
    S32 len;
    U16 tmp;

    tmp = obj_buff[8] + ((U16)obj_buff[9] << 8);

    if((Online_Calib.State & ONLINE_CALIB_FINNISH) == 0)
    {
        rev_buff[0] = 0x28;  //未准备好
        return -1;
    }

    if((tmp == 0xffff) && (obj_buff[6] & ONLINE_CALIB_TOTAL))
    {
        if(Online_Calib.State & ONLINE_CALIB_TRANSFERING)
        {
            rev_buff[0] = 0x26;  //校核数据正在外发
            return -1;
        }
        Online_Calib.State |= ONLINE_IN_USED;
        Online_Calib.State |= (obj_buff[6] & ONLINE_CALIB_TOTAL);
        Online_Calib.State |= ONLINE_CALIB_TRANSFERING;
        Online_Calib.Port_Num = Comm_Mem[index].Port_Num;
        Online_Calib.Mem_Num = 0xff;
        file_read(PAR_HVMADDR_04000401_00_ADDR, &Online_Calib.Address[0], 6);
        Online_Calib.Id[0] = ONLINE_CALIB_C;
        Online_Calib.Id[1] = 6;
        Online_Calib.Next_Seq_Len = 240;
        Online_Calib.Current_Seq = 1;

        for(i = 0; i < 4; i++)
        {
            rev_buff[i] = obj_buff[2 + i] + 0x33;
        }
        rev_buff[4] = ONLINE_CALIB_C + 0x33;
        rev_buff[5] = 6 + 0x33;
        rev_buff[6] = 0x33;
        rev_buff[7] = 0x33;
        for(i = 0; i < 240; i++)
        {
            rev_buff[i + 8] = Sample_Data[i] + 0x33;
        }
        len = 4 + 2 + 2 + 240;
        Online_Calib.State |= ONLINE_CALIB_READ_BEGIN;
    }
    else if(tmp > (ONLINE_CALIB_FRAME_NUM - 1))
    {
        rev_buff[0] = 0x25;  //帧号错误
        return -1;
    }
    else
    {
        if(obj_buff[6] == ONLINE_CALIB_C)
        {
//            Online_Calib.State &= (~ONLINE_CALIB_TOTAL);
            for(i = 0; i < 4; i++)
            {
                rev_buff[i] = obj_buff[2 + i] + 0x33;
            }
            rev_buff[4] = ONLINE_CALIB_C + 0x33;
            rev_buff[5] = 6 + 0x33;
            rev_buff[6] = 0x33 + obj_buff[8];
            rev_buff[7] = 0x33 + obj_buff[9];
            for(i = 0; i < 240; i++)
            {
                rev_buff[i + 8] = Sample_Data[8 * 30 * tmp + i] + 0x33;
            }
            len = 4 + 2 + 2 + 240;

        }
        else if(obj_buff[6] == ONLINE_CALIB_A)
        {
//            Online_Calib.State &= (~ONLINE_CALIB_TOTAL);
            if(A_C_Com.State & OUTSIDE_ASK)
            {
                len = deal_with_err_frame(rev_buff, 0x01);      //正在通信
                return len;
            }
            i = alloc_comm_mem();
            Comm_Mem[i].Buf[0] = 0x68;                          //组帧
            Comm_Mem[i].Buf[1] = 0x06;                          //标识码
            Comm_Mem[i].Buf[2] = 0x00;                          //功能码
            Comm_Mem[i].Buf[3] = 0x02;                          //数据长度
            Comm_Mem[i].Buf[4] = 0;                             //数据长度
            Comm_Mem[i].Buf[5] = obj_buff[8];;                  //数据长度
            Comm_Mem[i].Buf[6] = obj_buff[9];                   //CS校验码
            Comm_Mem[i].Buf[7] = cal_frmcs(&Comm_Mem[i].Buf[0], 7);
            Comm_Mem[i].Buf[8] = 0x16;                          //结束符
            Comm_Mem[i].Port_Num = GPRS;                        //串口
            Comm_Mem[i].Len = 0x09;                             //帧长
            Comm_Mem[i].Wait_Answer_Dly = DLY_50MS;             //发送后串口需等待这么长时间才能再使用
            A_C_Com.State = OUTSIDE_ASK;                        //置起A\C通信的标识
            A_C_Com.Outside_Ask_Mem_Num = i;                    //填入要发送的内存块标识
            Online_Calib.Port_Num = Comm_Mem[index].Port_Num;
            return -2;
        }
        else
        {
            len = deal_with_err_frame(rev_buff, 0x20);      //校准未完成
            return len;
        }
    }
    return len;

}
*/

/******************************************************************************
** 函数名称: S32 start_online_calib_frame(U8 *obj_buff, U8 *rev_buff, U8 pswd, U8 index)
** 函数功能: 启动在线校准帧处理
** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度,obj_buff[2..5]-标识
**           obj_buff[6...13]-操作者代码和密码，obj_buff[14][15]-厂家内部标识，
**           obj_buff[16..19]-采样数据模式,obj_buff[20...23]开始采样的相位
**           rev_buff：返回数据的地址，按DLT645规约返回的数据域格式
** 返 回 值: 其他表示数据域长度
             -1表示异常帧，长度为1，填入rev_buff[0]：0x3B表示密码错
             0x27表示校核正在运行中不允许再次启动
             0x30表示A相通信忙(外部有另外的请求A相的帧要发）
             0x29表示校核错误，具体见start_online_check()内部定义
             0x31表示当时申请内存失败
** 说    明: 无
******************************************************************************/
/*
S32 start_online_calib_frame(U8 *obj_buff, U8 *rev_buff, U8 pswd, U8 index)
{
    U8 i;
    U32 tmp3;
    U32 tmp1, tmp2;
    S32 len;

    len = 0;
    if(pswd < 11)
    {
        len = deal_with_err_frame(rev_buff, 8);
        return len;
    }

    if(Online_Calib.State & ONLINE_CALIB_RUNNING)
    {
        rev_buff[0] = 0x27;         //校核进行中
        return -1;
    }

    tmp1 = obj_buff[16] + ((U16)obj_buff[17] << 8) + ((U32)obj_buff[18] << 16) + ((U32)obj_buff[19] << 24);
    tmp2 = obj_buff[20] + ((U16)obj_buff[21] << 8) + ((U32)obj_buff[22] << 16) + ((U32)obj_buff[23] << 24);

    if(A_C_Com.State & OUTSIDE_ASK)
    {
        rev_buff[0] = 0x30;         //A相忙
        return -1;
    }
    tmp3 = start_online_check(tmp2, tmp1);
    if(tmp3 == -1u)
    {
        rev_buff[0] = 0x29;         //校核出错
        return -1;
    }
    Online_Calib.State &= (~ONLINE_CALIB_FINNISH);      //取消校核完成标识
    Online_Calib.State |= ONLINE_CALIB_RUNNING;         //置位校核运行中标识
    i = alloc_comm_mem();
    if(i >= COMM_MEM_NUM)
    {
        rev_buff[0] = 0x31;
        return -1;
    }
    Comm_Mem[i].Buf[0] = 0x68;                          //组帧
    Comm_Mem[i].Buf[1] = 0x05;                          //C相与A相的内部通信标识
    Comm_Mem[i].Buf[2] = 0x00;                          //C相与A相的内部通信标识
    Comm_Mem[i].Buf[3] = 0x08;                          //数据长度
    Comm_Mem[i].Buf[4] = 0;                             //数据长度
    Comm_Mem[i].Buf[5] = obj_buff[16];                  //状态字
    Comm_Mem[i].Buf[6] = obj_buff[17];                  //状态字
    Comm_Mem[i].Buf[7] = obj_buff[18];                  //状态字
    Comm_Mem[i].Buf[8] = obj_buff[19];                  //状态字
    Comm_Mem[i].Buf[9] = tmp3;                          //相位
    Comm_Mem[i].Buf[10] = (tmp3 >> 8);                  //相位
    Comm_Mem[i].Buf[11] = (tmp3 >> 16);                 //相位
    Comm_Mem[i].Buf[12] = (tmp3 >> 24);                 //相位
    Comm_Mem[i].Buf[5 + 8] = cal_frmcs(&Comm_Mem[i].Buf[0], 8 + 5 );  //填入校验码
    Comm_Mem[i].Buf[6 + 8] = 0x16;                      //填入结束符
    Comm_Mem[i].Wait_Answer_Dly = DLY_50MS;             //发送后串口需等待这么长时间才能再使用
    Comm_Mem[i].Port_Num = GPRS;                        //串口类型
    Comm_Mem[i].Len = 0x07 + 8;                         //发送帧的总长度
    A_C_Com.State |= OUTSIDE_ASK;                       //置起A\C通信的标识
    A_C_Com.Outside_Ask_Mem_Num = i;                    //填入要发送的内存块标识
    A_C_Com.Outside_Ask_Port_Num = Comm_Mem[index].Port_Num;//记录读写A相数据的外部通信串口
    return -2;
}
*/
/******************************************************************************
** 函数名称: void check_online(void)
** 函数功能: 处理自动发送现场校核数据
** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度,obj_buff[2..5]-标识
**           obj_buff[6...13]-操作者代码和密码，obj_buff[14][15]-厂家内部标识，
**           obj_buff[16]-采样数据模式,obj_buff[17][18]开始采样的相位
**           rev_buff：返回数据的地址，按DLT645规约返回的数据域格式
** 返 回 值: -1表示异常帧，其他表示数据域长度
** 说    明: 无
******************************************************************************/
/*
void check_online (void)
{
    U8 i, j;

    if((Online_Calib.State & ONLINE_CALIB_TOTAL) == 0)          //判断是否有要执行
    {
        return;
    }

    if(uart_open(Online_Calib.Port_Num, QUERY) ==__FAIL)        //判断请求校核数据的串口的发送状态是否空闲
    {
        return;
    }

    if((Sys_Tick - Online_Calib.Calib_Tick) < DLY_100MS)        //判断每帧的发送间隔是否到了，主要是上位机识别时间问题，可去掉
    {
        return;
    }


    i = alloc_comm_mem();                                       //申请内存
    if(i >= MAX_PORT_NUM)                                       //忙退出
    {
        return;
    }
    if(Online_Calib.State & ONLINE_CALIB_C)                     //C相还有未发完的校核数据
    {
        Comm_Mem[i].Buf[0] = 0x68;                              //组帧
        Comm_Mem[i].Buf[1] = Online_Calib.Address[0];           //地址
        Comm_Mem[i].Buf[2] = Online_Calib.Address[1];
        Comm_Mem[i].Buf[3] = Online_Calib.Address[2];
        Comm_Mem[i].Buf[4] = Online_Calib.Address[3];
        Comm_Mem[i].Buf[5] = Online_Calib.Address[4];
        Comm_Mem[i].Buf[6] = Online_Calib.Address[5];
        Comm_Mem[i].Buf[7] = 0x68;
        Comm_Mem[i].Buf[8] = 0x91;                              //功能码
        Comm_Mem[i].Buf[9] = Online_Calib.Next_Seq_Len + 8;     //长度
        Comm_Mem[i].Buf[10] = 0x01 + 0x33;                      //标识
        Comm_Mem[i].Buf[11] = 0x00 + 0x33;
        Comm_Mem[i].Buf[12] = 0x00 + 0x33;
        Comm_Mem[i].Buf[13] = 0x07 + 0x33;
        Comm_Mem[i].Buf[14] = Online_Calib.Id[0] + 0x33;        //厂家标识
        Comm_Mem[i].Buf[15] = Online_Calib.Id[1] + 0x33;
        Comm_Mem[i].Buf[16] = Online_Calib.Current_Seq + 0x33;  //帧号
        Comm_Mem[i].Buf[17] = (Online_Calib.Current_Seq >> 8) + 0x33;

        for(j = 0; j < Online_Calib.Next_Seq_Len; j++)          //拼数据
        {
            Comm_Mem[i].Buf[18 + j] = Sample_Data[8 * 30 * Online_Calib.Current_Seq + j] + 0x33;
        }
        Comm_Mem[i].Buf[18 + Online_Calib.Next_Seq_Len] = cal_frmcs(&Comm_Mem[i].Buf[0], 18 + Online_Calib.Next_Seq_Len);
        Comm_Mem[i].Buf[19 + Online_Calib.Next_Seq_Len] = 0x16; //结束符

        Comm_Mem[i].Len = 18 + 2 + Online_Calib.Next_Seq_Len;   //发送帧长度
        Comm_Mem[i].Port_Num = Online_Calib.Port_Num;           //发送串口

#ifdef __ALAN_TEST          //帧尾带4个字节的Sys_Tick调试用
                Comm_Mem[i].Buf[Comm_Mem[i].Len] = OS_Time;//Sys_Tick;                //tick
                Comm_Mem[i].Buf[Comm_Mem[i].Len + 1] = (OS_Time >> 8);     //tick
                Comm_Mem[i].Buf[Comm_Mem[i].Len + 2] = (OS_Time >> 16);    //tick
                Comm_Mem[i].Buf[Comm_Mem[i].Len + 3] = (OS_Time >> 24);    //tick
                Comm_Mem[i].Len += 4;
#endif

        if(uart_send(i) == __FAIL)
        {
            Comm_Mem[i].Flag = 0;
        }
        else
        {
            Online_Calib.Calib_Tick = OS_Time;//Sys_Tick;                             //更新校核状态的tick
            Online_Calib.Current_Seq++;                                     //发送后帧号自动加1

            if(Online_Calib.Current_Seq == (ONLINE_CALIB_FRAME_NUM - 1))    //发送的是倒数第2帧
            {
                Online_Calib.Next_Seq_Len = 128;                            //最后一帧的长度为200
            }
            if(Online_Calib.Current_Seq == ONLINE_CALIB_FRAME_NUM)          //最后一帧发完
            {
                Online_Calib.State &= ~ONLINE_CALIB_C;                      //C相数据全部发完
                Online_Calib.State &= (~ONLINE_CALIB_TRANSFERING);
                Online_Calib.Next_Seq_Len = 240;                            //准备发送A相的数据，帧长240
                Online_Calib.Current_Seq = 0;                               //A相的帧号也从0开始
            }
        }
    }
    else if(Online_Calib.State & ONLINE_CALIB_A)                //C相已经发完就判断A相
    {
        if(A_C_Com.State & OUTSIDE_ASK)                         //外部有读取A相数据的请求帧
        {
            Comm_Mem[i].Flag = 0;
            return;
        }
        Comm_Mem[i].Buf[0] = 0x68;                              //组帧
        Comm_Mem[i].Buf[1] = 0x06;                              //标识码
        Comm_Mem[i].Buf[2] = 0x00;                              //功能码
        Comm_Mem[i].Buf[3] = 0x02;                              //数据长度
        Comm_Mem[i].Buf[4] = 0;                                 //数据长度
        Comm_Mem[i].Buf[5] = Online_Calib.Current_Seq;          //数据长度
        Comm_Mem[i].Buf[6] = (Online_Calib.Current_Seq >> 8);   //CS校验码
        Comm_Mem[i].Buf[7] = cal_frmcs(&Comm_Mem[i].Buf[0], 7);
        Comm_Mem[i].Buf[8] = 0x16;                              //结束符
        Comm_Mem[i].Port_Num = GPRS;                            //串口
        Comm_Mem[i].Len = 0x09;                                 //帧长
        Comm_Mem[i].Wait_Answer_Dly = DLY_80MS;                 //发送后串口需等待这么长时间才能再使用
        A_C_Com.State |= OUTSIDE_ASK;                           //置起外部请求A相数据的标识
        A_C_Com.Outside_Ask_Mem_Num = i;                        //填入要发送的内存块标识
        Online_Calib.Calib_Tick = OS_Time;//Sys_Tick;                     //更新Tick，这里更新的话如果AC通信不正常的话，就不能保证间隔100ms读一次了。
        if(Online_Calib.Current_Seq == (ONLINE_CALIB_FRAME_NUM - 1))//最后一帧发完
        {
            Online_Calib.State &= (~ONLINE_CALIB_TRANSFERING);
        }
    }

}
*/
/******************************************************************************
** 函数名称: S32 deal_with_outside_transfer_a(U8 *obj_buff, U8 *rev_buff, U8 pswd, U8 index)
** 函数功能: 透传读写A相的数据
** 入口参数: obj_buff[0]-功能码,obj_buff[1]-数据域长度,obj_buff[2..5]-标识
**           obj_buff[6...13]-操作者代码和密码，obj_buff[14][15]-厂家内部标识，
**           obj_buff[16]-采样数据模式,obj_buff[17][18]开始采样的相位
**           rev_buff：返回数据的地址，按DLT645规约返回的数据域格式
** 返 回 值: -1表示异常帧，其他表示数据域长度
** 说    明: 无
******************************************************************************/
/*
S32 deal_with_outside_transfer_a(U8 obj_buff[], U8 rev_buff[], U8 pswd, U8 index)
{
    U8 i;
    U8 data_p;
    U16 tmp, j;
    S32 len;

    if(obj_buff[0] == 0x11)                                 //读指令
    {
        tmp = obj_buff[8] + (obj_buff[9] << 8);
        if(tmp != (obj_buff[1] - 8))                        //4ID + 2ID +2长度
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        data_p = 10;
    }
    else if(obj_buff[0] == 0x14)                            //写指令
    {
        if(pswd < 11)                                       //密码权限判断
        {
            len = deal_with_err_frame(rev_buff, 4);
            return len;
        }
        tmp = obj_buff[16] + (obj_buff[17] << 8);
        if(tmp != (obj_buff[1] - 16))                       //4字节ID + 4操作代码 + 4密码 + 2ID + 2长度
        {
            len = deal_with_err_frame(rev_buff, 2);
            return len;
        }
        data_p = 18;
    }
    else                                                    //功能码出错，调用正确基本不可能
    {
        len = deal_with_err_frame(rev_buff, 1);
        return len;
    }

    if(A_C_Com.State & OUTSIDE_ASK)                         //外部有读取A相数据的请求帧
    {
        len = deal_with_err_frame(rev_buff, 2);
        return len;
    }

    i = alloc_comm_mem();                                   //申请内存
    if(i >= MAX_PORT_NUM)                                   //忙退出
    {
        len = deal_with_err_frame(rev_buff, 1);
        return len;
    }
    Comm_Mem[i].Buf[0] = 0x68;                              //组帧
    Comm_Mem[i].Buf[1] = 0x07;                              //标识码
    Comm_Mem[i].Buf[2] = obj_buff[0];                       //功能码
    Comm_Mem[i].Buf[3] = tmp;                               //数据长度
    Comm_Mem[i].Buf[4] = (tmp >> 8);                        //数据长度
    for(j = 0; j < tmp; j++)
    {
        Comm_Mem[i].Buf[5 + j] = obj_buff[data_p + j];
    }
    Comm_Mem[i].Buf[5 + tmp] = cal_frmcs(&Comm_Mem[i].Buf[0], 5 + tmp);
    Comm_Mem[i].Buf[6 + tmp] = 0x16;                        //结束符
    Comm_Mem[i].Port_Num = GPRS;                            //串口
    Comm_Mem[i].Len = 7 + tmp;                              //帧长
    Comm_Mem[i].Wait_Answer_Dly = DLY_50MS;                 //发送后串口需等待这么长时间才能再使用
    A_C_Com.State |= OUTSIDE_ASK;                           //置起外部请求A相数据的标识
    A_C_Com.Outside_Ask_Mem_Num = i;                        //填入要发送的内存块标识
    A_C_Com.Outside_Ask_Port_Num = Comm_Mem[index].Port_Num;//记录读写A相数据的外部通信串口
    return -2;
}
*/

/******************************************************************************
** 函数名称: S8 deal_with_initiative_frame(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0
******************************************************************************/
S8 deal_with_initiative_frame (U8 *rcv)
{
    S8 err;

    switch(rcv[4])                                      //依据DI3判别
    {
    case 0:                                                                 //电能量数据标识
        err = deal_with_energy(rcv);
        break;
    case 1:                                                                 //最大需量及发生时间数据标识
        err = deal_with_demand(rcv);
        break;
    case 2:                                                                 //变量数据标识
        err = deal_with_variable(rcv);
        break;
    case 3:                                                                 //事件记录数据标识
        err = read_event(rcv);
        break;
    case 4:                                                                 //参变量数据标识
        err = read_parameter(rcv);
        break;
    case 5:                                                                 //冻结数据标识
        err = read_freeze(rcv);
        break;
    case 6:                                                                 //负荷记录数据标识
        err = read_load_profile(rcv);
        break;
    case 7:                                                                 //厂家标识[厂家自定义规约扩充标识]
        err = deal_with_manufacturer(rcv);
        break;
    default:                                                                //标识错误处理函数
        err = -1;
        break;
    }
    return err;
}

/******************************************************************************
** 函数名称: S8 deal_with_energy(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0,rcv[x:5]为有效数据
******************************************************************************/
S8 deal_with_energy (U8 *rcv)
{
    U8 len,cmp[TOTAL_PHASE_ENERGY_LEN];
    U16 crc=0;
    U32 base,cnt;
    U32 index;                  //外存地址或内存数组下标

    len = rcv[0] - 4;           //有效数据长度

    if(rcv[1] == 0)             //依据DI0判别处理:当前电量[内存保存]
    {
        if(rcv[3] <= 0x0A)      //DI2:合相数据
        {
            base = 0;
            index = base + TOTAL_PHASE_ENERGY_LEN * rcv[3] + (rcv[2] % 0xFF) * ENERGY_LEN;   //计算数据存储数组下标[包含数据块读取DI1=FF]
        }
        else
        {//关联电能&分相电能块依照厂家扩展DI移至deal_with_manufacture()中解析
            return -1;
        }
        memcpy(gEngArray + index, rcv + 5, len);    //保存数据
        if(rcv[2] == 0xFF)
        {
            crc = calc_crc16(gEngArray + index, ENG_COMPOSP_00000000_TOT_LEN - CRC_LEN, 0xFFFF);
        }
        memcpy(gEngArray + index + TOTAL_PHASE_ENERGY_LEN - CRC_LEN, (U8 *)&crc, CRC_LEN);//保存数据
        return 1;
    }
    else if(rcv[1] <= 0x0C)     //依据DI0判别处理:1~12结算日电量[外存保存]
    {
        if((rcv[3] <= 0x0A) && (rcv[2] == 0xFF))      //DI2:合相数据
        {
            file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);//暂存次数指针及其CRC
            if(((U16)byte_merge1(cmp + 3, 2) == calc_crc16(cmp, 3, 0xffff)))     //CRC比对:若相同,数据比对
            {
                cnt = byte_merge1(cmp, 3);   //获取次数指针

                base = ENG_LASTXMONTH_00000000_00_HEAD_ADDR + (cnt % 12) * ENG_LASTXMONTH_00000000_00_OFFSET_BLOCKLEN;//cnt%12∈[0,11]
                base += TOTAL_PHASE_ENERGY_LEN * rcv[3];                        //合相某项电能数据块基址
                file_read(base, cmp, TOTAL_PHASE_ENERGY_LEN);                   //合相某项电能数据块读取

                if(compare_update_buf(cmp, rcv + 8, TOTAL_PHASE_ENERGY_LEN - 2))//比对(不比对2字节的CRC)
                {
                    crc = calc_crc16(cmp, ENERGY_LEN * 5, 0xffff);
                    cmp[ENERGY_LEN * 5] = crc >> 0;
                    cmp[ENERGY_LEN * 5 + 1] = crc >> 8;
                    file_write(base, cmp, TOTAL_PHASE_ENERGY_LEN);              //更新外存合相关联电能
                    Eng_Up_Flg |= (1 << rcv[3]);                                //对应项标识置位
                }
                else
                {
                    return 1;
                }

                if((0x1FFF == (Eng_Up_Flg & 0x1FFF)))                           //处理次数指针
                {
                    Eng_Up_Flg = 0;         //标识复位
                    cnt++;
                    cnt %= 0xFFFFFF;        //确保次数指针三字节的取值范围
                    cmp[0] = cnt >> 0;
                    cmp[1] = cnt >> 8;
                    cmp[2] = cnt >> 16;
                    cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算新的CRC
                    cmp[4] = crc >> 8;
                    file_write(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);
                }
            }
            else                                                                //若不同，则认为是首次
            {
                base = ENG_LASTXMONTH_00000000_00_HEAD_ADDR;
                base += TOTAL_PHASE_ENERGY_LEN * rcv[3];                        //合相某项电能数据块基址
                crc = calc_crc16(rcv + 8, ENERGY_LEN * 5, 0xffff);
                rcv[8 + ENERGY_LEN * 5] = crc >> 0;   //借用RCV末尾2字节
                rcv[8 + ENERGY_LEN * 5 + 1] = crc >> 8;
                file_write(base, rcv + 8, ENERGY_LEN * 5 + CRC_LEN);            //保存合相某项关联电能
                Eng_Up_Flg |= (1 << rcv[3]);                                    //对应项标识置位

                if((0x1FFF == (Eng_Up_Flg & 0x1FFF)))                           //处理次数指针
                {
                    Eng_Up_Flg = 0;         //标识复位
                    cmp[2] = cmp[1] = cmp[0] = 0;                               //次数复位
                    cmp[3] = crc = calc_crc16(rcv, 3, 0xffff);                  //计算CRC并填充buf
                    cmp[4] = crc >> 8;
                    file_write(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);//保存次数指针
                }
            }
            return 1;
        }
        else if(rcv[2] != 0xFF)//显示发起的抄读命令 同步的话都是数据块命令
        {
            if(rcv[0] < TMP_RAM_ARRAY_MAX)
            {
                memcpy(gTmpArray, rcv, rcv[0] + 1);//临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
                set_di_sync_finish(1);//比对数据标识 置读到标识标志
#endif
            }
            return 1;
        }
        else
        {
            return -1;
        }
    }
    else                        //标识错误
    {
        return -1;
    }
}

/******************************************************************************
** 函数名称: S8 deal_with_demand(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0,rcv[x:5]为有效数据
******************************************************************************/
S8 deal_with_demand (U8 *rcv)
{
    U8 len,mem_type;
    U8 *cmp=NULL;
    U16 crc;
    U32 base,cnt;
    U32 index=0;                  //外存地址或内存数组下标

    cmp = alloc_comm_mem(MEM_64_TYPE, &mem_type, GET_MEM_ERR13);
    if(NULL == cmp)
    {
//          memcpy(gusCurMemErrFunName, "deal_wit", 8);
        setmemgetnullid(GET_MEM_ERR13, gusCurMemErrFunName);
        return -1;              //申请内存失败
    }

    len = rcv[0] - 4;           //有效数据长度

    if(rcv[1] == 0)             //依据DI0判别处理:当前电量[内存保存]
    {
        if((rcv[3] >= 0x01) && (rcv[3] <= 0x0A))      //DI2:合相数据
        {
            base = 0;
            index = base + TOTAL_PHASE_DEMAND_LEN * (rcv[3] - 1) + (rcv[2] % 0xFF) * DEMAND_LEN;   //计算数据存储数组下标[包含数据块读取DI1=FF]

            memcpy(gDmdArray + index, rcv + 5, len);  //保存数据
            free_mem_block(cmp);    //释放内存块
            return 1;
        }
        else                    //DI2分相电量[移至厂家扩充规约部分解析处理]
        {
            free_mem_block(cmp);    //释放内存块
            return -1;
        }
    }
    else if(rcv[1] <= 0x0C)     //依据DI0判别处理:1~12结算日电量[外存保存]
    {

        if((rcv[3] <= 0x0A) && (rcv[2] == 0xFF))     //DI2:合相数据块
        {
            file_read(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//暂存次数指针及其CRC
            if(((U16)byte_merge1(cmp + 3, 2) == calc_crc16(cmp, 3, 0xffff)))     //CRC比对:若相同,数据比对
            {
                cnt = byte_merge1(cmp, 3);   //获取次数指针

                base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR + (cnt % 12) * DMD_LASTXMONTH_01010001_00_OFFSET_BLOCKLEN;//cnt%12∈[1,11]
                base += TOTAL_PHASE_DEMAND_LEN * (rcv[3] - 1);                  //合相某项最大需量及发生时间数据块基址
                file_read(base, cmp, TOTAL_PHASE_DEMAND_LEN);                   //合相某项最大需量及发生时间数据块读取

                if(compare_update_buf(cmp, rcv + 8, TOTAL_PHASE_DEMAND_LEN))    //比对
                {
                    file_write(base, cmp, TOTAL_PHASE_DEMAND_LEN);              //更新外存合相某项最大需量及发生时间数据块
                    Dmd_Up_Flg |= (1 << (rcv[3] - 1));                          //对应项标识置位
                }
                else
                {
                    free_mem_block(cmp);    //释放内存块
                    return 1;
                }

#ifdef PHASE_3_LINE_4//PHASE_3_LINE_4
                if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#else   //PHASE_3_LINE_4
                if(0x0BFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#endif  //PHASE_3_LINE_4
                {
                    Dmd_Up_Flg = 0;                     //标识复位
                    cnt++;
                    cnt %= 0xFFFFFF;                    //确保次数指针三字节的取值范围
                    cmp[0] = cnt >> 0;
                    cmp[1] = cnt >> 8;
                    cmp[2] = cnt >> 16;
                    cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算新的CRC
                    cmp[4] = crc >> 8;
                    file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);
                }
            }
            else                                                                //若不同，则认为是首次
            {
                base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR;                    //合相最大需量及发生时间数据块首址
                file_write(base, rcv + 8, TOTAL_PHASE_DEMAND_LEN);              //更新外存合相某项最大需量及发生时间数据块
                Dmd_Up_Flg |= (1 << (rcv[3] - 1));                              //对应项标识置位

#ifdef PHASE_3_LINE_4//PHASE_3_LINE_4
                if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#else   //PHASE_3_LINE_4
                if(0x0BFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#endif  //PHASE_3_LINE_4
                {
                    Dmd_Up_Flg = 0;                     //标识复位
                    cmp[2] = cmp[1] = cmp[0] = 0;                               //次数归零
                    cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算CRC并填充buf
                    cmp[4] = crc >> 8;
                    file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//保存次数指针
                }
            }
            free_mem_block(cmp);    //释放内存块
            return 1;
        }
        else if(rcv[2] != 0xFF)//显示发起的抄读命令 同步的话都是数据块命令
        {
            if(rcv[0] < TMP_RAM_ARRAY_MAX)
            {
                memcpy(gTmpArray, rcv, rcv[0] + 1);//临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
                set_di_sync_finish(1);
#endif                
            }
            free_mem_block(cmp);    //释放内存块
            return 1;
        }
        else
        {
            free_mem_block(cmp);    //释放内存块
            return -1;
        }
    }
    else                        //标识错误
    {
        free_mem_block(cmp);    //释放内存块
        return -1;
    }
}

/******************************************************************************
** 函数名称: S8 deal_with_variable(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0,rcv[x:5]为有效数据
******************************************************************************/
S8 deal_with_variable (U8 *rcv)
{

    if((rcv[3] <= 11) || (rcv[3] == 0x80))   //变量的DI2:取值
    {
        if((rcv[2] <= 3) || (rcv[2] == 0xFF))//变量的DI1:取值
        {
            if((rcv[1] <= 21) || (rcv[1] == 0xFF))//变量的DI0:取值
            {
                memcpy(gTmpArray, rcv, rcv[0] + 1);//临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
                set_di_sync_finish(1);
#endif                
                return 1;
            }
            else
            {
                return -1;
            }
        }
        else
        {
            return -1;
        }
    }
    else
    {
        return -1;
    }
}

/******************************************************************************
** 函数名称: S8 read_parameter(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0,rcv[x:5]为有效数据
******************************************************************************/
S8 read_parameter (U8 *rcv)
{
//    U8 i;

    if((rcv[3] <= 4) || (rcv[3] == 0x80))   //参变量的DI2:取值
    {
        if(rcv[2] <= 0x0E)
        {
            if(rcv[2] == 1)
            {
                switch(rcv[1])
                {
                case 1:                 //日期&周次
//                    for(i = 0; i < 4; i++)
//                    {
//                        bcd_to_hex(rcv[5 + i]);                 //转换为HEX格式
//                    }
                    Calendar.Day = bcd_to_hex(rcv[5]);                      //星期
                    Calendar.Date = bcd_to_hex(rcv[6]);                     //日
                    Calendar.Month = bcd_to_hex(rcv[7]);                    //月
                    Calendar.Year = bcd_to_hex(rcv[8]);                     //年
                    break;
                case 2:                 //时间
//                    for(i = 0; i < 3; i++)
//                    {
//                        bcd_to_hex(rcv[5 + i]);                 //转换为HEX格式
//                    }
                    Calendar.Sec = bcd_to_hex(rcv[5]);                      //秒
                    Calendar.Min = bcd_to_hex(rcv[6]);                      //分
                    Calendar.Hour = bcd_to_hex(rcv[7]);                     //时
                    break;
                case 0xFF:  //扩展数据块,仅存日期&周次和时间数据其它丢弃[移至厂家扩充标识处理]
//                    for(i = 0; i < 7; i++)
//                    {
//                        bcd_to_hex(rcv[5 + i]);                 //转换为HEX格式
//                    }
                    Calendar.Sec = bcd_to_hex(rcv[5]);                      //秒
                    Calendar.Min = bcd_to_hex(rcv[6]);                      //分
                    Calendar.Hour = bcd_to_hex(rcv[7]);                     //时
                    Calendar.Day = bcd_to_hex(rcv[8]);                      //星期
                    Calendar.Date = bcd_to_hex(rcv[9]);                     //日
                    Calendar.Month = bcd_to_hex(rcv[10]);                   //月
                    Calendar.Year = bcd_to_hex(rcv[11]);                    //年
                    break;
                default:
                    memcpy(gTmpArray, rcv, rcv[0] + 1);           //临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
                    set_di_sync_finish(1);
#endif
                    break;
                }
                return 1;
            }
            else if(rcv[2] == 5)
            {
                switch(rcv[1])
                {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    memcpy((U8*)gMeter_State + (rcv[1] - 1)*2, rcv + 1, 2);    //存储电表运行状态字
                    break;
                case 0xFF://数据块//azh 120317
                   	memcpy((U8*)gMeter_State, rcv + 5, 14);                   //存储电表运行状态字数据块
                    break;
                default:
                    return -1;                      //标识错误
                }
                return 1;
            }
            else
            {
                memcpy(gTmpArray, rcv, rcv[0] + 1);    //临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
                set_di_sync_finish(1);
#endif
                return 1;
            }
        }
        else
        {
            return -1;
        }
    }
    else
    {
        return -1;
    }
}

/******************************************************************************
** 函数名称: S32 deal_with_display_terminal_frame(U8 *obj_buff, U8 *rev_buff, U8 pswd)
** 函数功能: 解析显示终端的标识帧
** 入口参数: obj_buff[0]为功能码，rev_buff[]返回的帧填充地址，rev_buff[0]从标识
**           码开始，已加0x33。
**           1、对应读的：obj_buff[0]-功能码,[1]-数据域长度,
**              [2..5]-标识，[6][7]-厂家内部标识，[8]当前或上几次数据的标识
                obj_buff[10...]数据
                [6][7] = 0009  显示终端读时间数据块
                       = 0109  显示终端读关联的总、A、C电能量3个数据块60字节
                       = 0209  显示终端读A、C相电能数据块
                       = 0309  显示终端读A相最大需量及发生时间数据块
                       = 0409  显示终端读B相最大需量及发生时间数据块
                       = 0509  显示终端读C相最大需量及发生时间数据块
**           2、对应写的：obj_buff[0]-功能码,[1]-数据域长度,[2..5]-标识，
                [6...13]-操作者代码和密码[14][15]-厂家内部标识，
                [16]显示终端自定义标识，[17...]数据
                [15]必须为09H
**           rev_buff：返回数据的地址，按DLT645规约返回的数据域格式
** 返 回 值: len :数据域长度，
**           -1  :表示错误帧处理，调用deal_with_err_frame()处理异常应答
** 说    明: 07
******************************************************************************/
#if CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块
// S32 deal_with_display_terminal_frame (U8 *obj_buff, U8 *rev_buff, U8 pswd)
// {
// //    U8 i, j, k;
//     U8 mem_type;
//     U8 *tmp=NULL;
//     S32 len=0;
//     U32 add;
//     U32 point;
//     U32 point_offset;

// //    add = 0;
// //    j = 0;
//     if(obj_buff[0] == 0x11) //读数据
//     {
// //        if(obj_buff[8] != 0)
// //        {
// //            file_read(ACCOUNT_DAY_DATA_POINTER, (U8 *)&point, 1);
// //            point_offset = decrease_event_record_point(point, ACCOUNT_DAY_DATA_NUM, obj_buff[8]);
// //            if(__FAIL == (S8)point_offset)
// //            {
// //                rev_buff[0] = 0x35;
// //                return -1;
// //            }
// //            else
// //            {
// //                point_offset &= 0x7f;
// //            }
// //            add = point_offset * SINGLE_ACCOUNT_DAY_DATA_LEN;
// //            j = 1;
// //        }
// /*        if(obj_buff[8] == 0)    //当月数据不在此处理?
//         {
//             return -1;
//         }*/
//         tmp = alloc_comm_mem(MEM_256_TYPE, &mem_type, GET_MEM_ERR14);
//         if(NULL == tmp)
//         {
// //          memcpy(gusCurMemErrFunName, "deal_wid", 8);
//             setmemgetnullid(GET_MEM_ERR14, gusCurMemErrFunName);
//             return -1;           //申请内存失败
//         }
//  //----------------读指令-----------------------------
//         switch(obj_buff[6])
//         {
//         case 0:                             //读时间块的
//             get_hardware_rtc(rev_buff + 7);
//             len = 7;
//             break;
//         case 1:                             //读关联电量的总的，A相的，C相的,每相5(或7)*4字节
//             if(obj_buff[8] == 0)            //当月数据
//             {
//                 file_read(ENG_RELATOTP_00800000_00_ADDR, tmp, ENG_ALL_RELATOTP_TOT_LEN);
//                 len = ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN;
//                 if(((U16)byte_merge1(tmp + len, 2) != calc_crc16(tmp, len, 0xffff)))     //CRC比对:若不同
//                 {
//                     rev_buff[0] = 0x35;
//                     free_mem_block(tmp);    //释放内存块
//                     return -1;
//                 }
//                 else
//                 {
//                     memcpy(rev_buff + 7, tmp, len);
//                 }
//             }
//             else if(obj_buff[8] <= 12)      //结算日数据
//             {
//                 file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, tmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);
//                 if(((U16)byte_merge1(tmp + 3, 2) != calc_crc16(tmp, 3, 0xffff)))     //CRC比对:若不同
//                 {
//                     rev_buff[0] = 0x35;
//                     free_mem_block(tmp);    //释放内存块
//                     return -1;
//                 }
//                 else
//                 {
//                     point = byte_merge1(tmp, 3);
//                     point_offset = point % 12;  //求出当前指针(对应第一结算日)
//                 }
//                 add = ENG_LASTXMONTH_00000000_00_HEAD_ADDR + point_offset * ENG_LASTXMONTH_00000000_00_OFFSET_BLOCKLEN;
//                 add += ENG_MERGED_PHASE_TOT_LEN + ENG_SEPARATE_PHASE_TOT_LEN;
//                 len = ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN;
//                 file_read(add, rev_buff + 7, len);
//             }
//             else
//             {
//                 rev_buff[0] = 0x35;
//                 free_mem_block(tmp);    //释放内存块
//                 return -1;
//             }
// //            for(i = 0; i < 3; i++)
// //            {
// //                file_read(display_related_energy_table[i][j] + add, rev_buff + 7 + 5 * ENERGY_LEN * i, 5 * ENERGY_LEN);
// //            }
// //            len = 5 * 4 * 3;
// //            if(j == 0)                      //当前的值需要转化为BCD码
// //            {
// //#ifdef ENERGY_WITH_THREE_DECIMAL
// //                file_read(ENERGY_DECIMAL_ADDR, &k, ENERGY_DECIMAL_LEN);
// //#else// ENERGY_WITH_THREE_DECIMAL
// //                k = 2;
// //#endif// ENERGY_WITH_THREE_DECIMAL
// //                for(i = 0; i < (len >> 2); i++)//15个数据，0，5，10是有符号的是关联总电能
// //                {
// //                    if((i == 0) || (i == 5) || (i == 10))
// //                    {
// //                        energy_to_format_data(rev_buff + 7 + 4 * i, rev_buff + 7 + 4 * i, 0, k);    //转换成BCD码
// //                    }
// //                    else
// //                    {
// //                        energy_to_format_data(rev_buff + 7 + 4 * i, rev_buff + 7 + 4 * i, 0xff, k); //转换成BCD码
// //                    }
// //                }
// //            }
//             break;
//         case 2:                             //读A、(B、)C相电能数据块，每相10*4字节
//             if(obj_buff[8] == 0)            //当月数据
//             {
//                 file_read(ENG_APOSP_00150000_00_ADDR, tmp, ENG_SEPARATE_PHASE_TOT_LEN);
//                 len = ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN;
//                 if(((U16)byte_merge1(tmp + len, 2) != calc_crc16(tmp, len, 0xffff)))     //CRC比对:若不同
//                 {
//                     rev_buff[0] = 0x35;
//                     free_mem_block(tmp);    //释放内存块
//                     return -1;
//                 }
//                 else
//                 {
//                     memcpy(rev_buff + 7, tmp, len);
//                 }
//             }
//             else if(obj_buff[8] <= 12)      //结算日数据
//             {
//                 file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, tmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);
//                 if(((U16)byte_merge1(tmp + 3, 2) != calc_crc16(tmp, 3, 0xffff)))     //CRC比对:若不同
//                 {
//                     rev_buff[0] = 0x35;
//                     free_mem_block(tmp);    //释放内存块
//                     return -1;
//                 }
//                 else
//                 {
//                     point = byte_merge1(tmp, 3);
//                     point_offset = point % 12;  //求出当前指针(对应第一结算日)
//                 }
//                 add = ENG_LASTXMONTH_00000000_00_HEAD_ADDR + point_offset * ENG_LASTXMONTH_00000000_00_OFFSET_BLOCKLEN;
//                 add += ENG_MERGED_PHASE_TOT_LEN;
//                 len = ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN;
//                 file_read(add, rev_buff + 7, len);
//             }
//             else
//             {
//                 rev_buff[0] = 0x35;
//                 free_mem_block(tmp);    //释放内存块
//                 return -1;
//             }
// //            for(i = 0; i < 2; i++)
// //            {
// //                file_read(display_energy_table[i][j] + add, rev_buff + 7 + 10 * ENERGY_LEN * i, 10 * ENERGY_LEN);
// //            }
// //            len = 10 * 4 * 2;
// //            if(j == 0)                      //当前的值需要转化为BCD码
// //            {
// //#ifdef ENERGY_WITH_THREE_DECIMAL
// //                file_read(ENERGY_DECIMAL_ADDR, &k, ENERGY_DECIMAL_LEN);
// //#else// ENERGY_WITH_THREE_DECIMAL
// //                k = 2;
// //#endif// ENERGY_WITH_THREE_DECIMAL
// //                for(i = 0; i < (len >> 2); i++)//20个数据，2，3，12，13是有符号的，是组合无功1，2
// //                {
// //                    if((i == 2) || (i == 3) || (i == 12) || (i == 13))
// //                    {
// //                        energy_to_format_data(rev_buff + 7 + 4 * i, rev_buff + 7 + 4 * i, 0, k);    //转换成BCD码
// //                    }
// //                    else
// //                    {
// //                        energy_to_format_data(rev_buff + 7 + 4 * i, rev_buff + 7 + 4 * i, 0xff, k); //转换成BCD码
// //                    }
// //                }
// //            }
//             break;
//         case 3:                             //读A相最大需量及发生时间数据块
//             if(obj_buff[8] == 0)            //当月数据
//             {
//                 len = SINGLE_PHASE_DEMAND_LEN;
//                 file_read(DMD_APOSP_01150000_00_ADDR, rev_buff + 7, len);
//             }
//             else if(obj_buff[8] <= 12)      //结算日数据
//             {
//                 file_read(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, tmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);
//                 if(((U16)byte_merge1(tmp + 3, 2) != calc_crc16(tmp, 3, 0xffff)))     //CRC比对:若不同
//            {
//                rev_buff[0] = 0x35;
//                     free_mem_block(tmp);    //释放内存块
//                return -1;
//            }
//            else
//            {
//                     point = byte_merge1(tmp, 3);
//                     point_offset = point % 12;  //求出当前指针(对应第一结算日)
//            }
//                 add = DMD_LASTXMONTH_01010001_00_HEAD_ADDR + point_offset * DMD_LASTXMONTH_01010001_00_OFFSET_BLOCKLEN;
//                 add += ((TOTAL_PHASE_DEMAND_LEN * 10) + (SINGLE_PHASE_DEMAND_LEN * 0));
//                 len = SINGLE_PHASE_DEMAND_LEN;
//                 file_read(add, rev_buff + 7, len);
//        }
//             else
//            {
//                 rev_buff[0] = 0x35;
//                 free_mem_block(tmp);    //释放内存块
//                 return -1;
//            }
//             break;
//         case 4:                             //读B相最大需量及发生时间数据块
// #ifdef PHASE_3_LINE_4
//             if(obj_buff[8] == 0)            //当月数据
//            {
//                 len = SINGLE_PHASE_DEMAND_LEN;
//                 file_read(DMD_BPOSP_01290000_00_ADDR, rev_buff + 7, len);
//             }
//             else if(obj_buff[8] <= 12)      //结算日数据
//                {
//                 file_read(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, tmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);
//                 if(((U16)byte_merge1(tmp + 3, 2) != calc_crc16(tmp, 3, 0xffff)))     //CRC比对:若不同
//                    {
//                     rev_buff[0] = 0x35;
//                     free_mem_block(tmp);    //释放内存块
//                     return -1;
//                    }
//                    else
//                    {
//                     point = byte_merge1(tmp, 3);
//                     point_offset = point % 12;  //求出当前指针(对应第一结算日)
//                    }
//                 add = DMD_LASTXMONTH_01010001_00_HEAD_ADDR + point_offset * DMD_LASTXMONTH_01010001_00_OFFSET_BLOCKLEN;
//                 add += ((TOTAL_PHASE_DEMAND_LEN * 10) + (SINGLE_PHASE_DEMAND_LEN * 1));
//                 len = SINGLE_PHASE_DEMAND_LEN;
//                 file_read(add, rev_buff + 7, len);
//                }
//             else
//             {
//                 rev_buff[0] = 0x35;
//                 free_mem_block(tmp);    //释放内存块
//                 return -1;
//             }
// #else   //PHASE_3_LINE_4
//             len = SINGLE_PHASE_DEMAND_LEN;
//             for(i = 0; i < len; i++)
//             {
//                 rev_buff[i + 7] = 0;
//            }
// #endif  //PHASE_3_LINE_4
//             break;
//         case 5:                             //读C相最大需量及发生时间数据块
//             if(obj_buff[8] == 0)            //当月数据
//            {
//                 len = SINGLE_PHASE_DEMAND_LEN;
//                 file_read(DMD_CPOSP_013D0000_00_ADDR, rev_buff + 7, len);
//            }
//             else if(obj_buff[8] <= 12)      //结算日数据
//            {
//                 file_read(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, tmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);
//                 if(((U16)byte_merge1(tmp + 3, 2) != calc_crc16(tmp, 3, 0xffff)))     //CRC比对:若不同
//                {
//                     rev_buff[0] = 0x35;
//                     free_mem_block(tmp);    //释放内存块
//                     return -1;
//                 }
//                 else
//                    {
//                     point = byte_merge1(tmp, 3);
//                     point_offset = point % 12;  //求出当前指针(对应第一结算日)
//                 }
//                 add = DMD_LASTXMONTH_01010001_00_HEAD_ADDR + point_offset * DMD_LASTXMONTH_01010001_00_OFFSET_BLOCKLEN;
// #ifdef PHASE_3_LINE_4
//                 add += ((TOTAL_PHASE_DEMAND_LEN * 10) + (SINGLE_PHASE_DEMAND_LEN * 2));
// #else   //PHASE_3_LINE_4
//                 add += ((TOTAL_PHASE_DEMAND_LEN * 10) + (SINGLE_PHASE_DEMAND_LEN * 1));
// #endif  //PHASE_3_LINE_4
//                 len = SINGLE_PHASE_DEMAND_LEN;
//                 file_read(add, rev_buff + 7, len);
//                    }
//                    else
//                    {
//                 rev_buff[0] = 0x35;
//                 free_mem_block(tmp);    //释放内存块
//                 return -1;
//             }
//             break;
//         default:
//             free_mem_block(tmp);    //释放内存块
//             return deal_with_err_frame(rev_buff, 2);            //标识码错误，返回无请求数据
//                    }
//         free_mem_block(tmp);    //释放内存块
//     }
// //--------写命令--------------------------------------------------
//     else if(obj_buff[0] == 0x14)
//     {
//         return 0;
//                }
//     else
//     {
//         return deal_with_err_frame(rev_buff, 1);                //功能码错，返回其他错误
//            }

//     after_fram_flag = 0;
//     memcpy(rev_buff, obj_buff + 2, 7);
//     buf_add_33(rev_buff, len + 7);
//     return (len + 7);
// }
#endif//CODE_VER_TYPE!=GPRS_MODULE_PRJ		//不带CPU_GPRS模块

/******************************************************************************
** 函数名称: S8 read_event(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0,rcv[x:5]为有效数据
******************************************************************************/
S8 read_event (U8 *rcv)
{

    if((rcv[3] <= 0x12) || (rcv[3] == 0x30))//事件的DI2:取值
    {
        if(rcv[2] <= 0x0E)
        {
            memcpy(gTmpArray, rcv, rcv[0] + 1);//临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
            set_di_sync_finish(1);
#endif            
            return 1;
        }
        else
        {
            return -1;
        }
    }
    else
    {
        return -1;
    }
}

/******************************************************************************
** 函数名称: S8 read_freeze(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0,rcv[x:5]为有效数据
******************************************************************************/
S8 read_freeze (U8 *rcv)
{

    if(rcv[3] <= 3)         //冻结的DI2:取值
    {
        memcpy(gTmpArray, rcv, rcv[0] + 1);//临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
        set_di_sync_finish(1);
#endif
        return 1;
    }
    else
    {
        return -1;
    }
}

/******************************************************************************
** 函数名称: S8 read_load_profile(U8 *rcv)
** 函数功能: 依照dlt645规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为DI3:DI0,rcv[x:5]为有效数据
******************************************************************************/
S8 read_load_profile (U8 *rcv)
{

    if(rcv[3] <= 6)         //负荷记录的DI2:取值
    {
        memcpy(gTmpArray, rcv, rcv[0] + 1);//临时保存[总长度:lenth + DI + DATA]
#ifdef LCD_VALID
        set_di_sync_finish(1);
#endif
        return 1;
    }
    else
    {
        return -1;
    }
}

/******************************************************************************
** 函数名称: S8 deal_with_manufacturer(U8 *rcv)
** 函数功能: 依照dlt645(厂家扩充)规约解析显示终端主动读取到高压表的返回帧
** 入口参数: U8 *rcv : 接收帧数组指针
** 返 回 值: -1 ：错误
**            1 ：正常处理
** 说    明: rcv[0]为DL645的数据域长度,rcv[4:1]为标准规约标识DI3:DI0 = [07 00 00 01],
**           rcv[7:5]为厂家扩充规约标识DI6:DI4,rcv[x:8]为有效数据
******************************************************************************/
S8 deal_with_manufacturer (U8 *rcv)
{
    U8 mem_type;
    U8 *cmp=NULL;
    U16 crc;
    U32 base,cnt;

    if((!rcv[3]) && (!rcv[2]) && (rcv[1] == 1))         //确认是厂家扩充标识
    {
//azh
        cmp = alloc_comm_mem(MEM_256_TYPE, &mem_type, GET_MEM_ERR15);
        if(NULL == cmp)
        {
//          memcpy(gusCurMemErrFunName, "deal_wim", 8);
            setmemgetnullid(GET_MEM_ERR15, gusCurMemErrFunName);
            return -1;              //申请内存失败
        }
        switch(rcv[5])          //依据DI4判别:各项
        {
        case 0:                 //时间日期数据块
            if(rcv[6] == 9)     //DI5=09:显示终端专属
            {
//                for(i = 0; i < 7; i++)
//                {
//                    bcd_to_hex(rcv[8 + i]);             //转换为HEX格式
//                }
                Calendar.Sec = bcd_to_hex(rcv[8]);                  //秒
                Calendar.Min = bcd_to_hex(rcv[9]);                  //分
                Calendar.Hour = bcd_to_hex(rcv[10]);                //时
                Calendar.Day = bcd_to_hex(rcv[11]);                 //星期
                Calendar.Date = bcd_to_hex(rcv[12]);                //日
                Calendar.Month = bcd_to_hex(rcv[13]);               //月
                Calendar.Year = bcd_to_hex(rcv[14]);                //年
                free_mem_block(cmp);    //释放内存块
                gucPoweronGetTimeOver = 0xa5;
                return 1;
            }
            else                //其它设备
            {
                free_mem_block(cmp);    //释放内存块
                return -1;
            }

        case 1:                 //合相关联电能量数据块及分相A、B、C关联电能量数据块集合
            if(rcv[6] == 9)     //DI5=09:显示终端专属
            {
                switch(rcv[7])  //依据DI6判别:当前或上几个月
                {
                case 0:         //当前[放在内存]
                    base = ENG_MERGED_PHASE_TOT_LEN + ENG_SEPARATE_PHASE_TOT_LEN;   //合相关联电能起始下标
                    memcpy(gEngArray + base, rcv + 8, ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN);//保存数据
                    crc = calc_crc16(gEngArray + base, ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN, 0xFFFF);
                    memcpy(gEngArray + base + ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN, (U8 *)&crc, CRC_LEN);//保存数据
                    break;
                case 1:         //结算日[比对保存并更新次数指针]
                    file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);//暂存次数指针及其CRC
                    if(((U16)byte_merge1(cmp + 3, 2) == calc_crc16(cmp, 3, 0xffff)))    //CRC比对:若相同,数据比对
                    {
                        cnt = byte_merge1(cmp, 3);  //获取次数指针

                        base = ENG_LASTXMONTH_00000000_00_HEAD_ADDR + (cnt % 12) * ENG_LASTXMONTH_00000000_00_OFFSET_BLOCKLEN;//cnt%12∈[0,11]
                        base += (ENG_MERGED_PHASE_TOT_LEN + ENG_SEPARATE_PHASE_TOT_LEN);//合相关联电能基址
                        file_read(base, cmp, ENG_ALL_RELATOTP_TOT_LEN);                 //合、分相关联电能+CRC读取

                        if(compare_update_buf(cmp, rcv + 8, ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN))//比对
                        {
                            crc = calc_crc16(rcv + 8, ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN, 0xFFFF);
                            cmp[ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN] = crc >> 0;   //借用CMP[]2字节填充CRC
                            cmp[ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN + 1] = crc >> 8;   //借用CMP[]2字节填充CRC
                            file_write(base, cmp, ENG_ALL_RELATOTP_TOT_LEN);  //更新外存合、分相关联电能块及CRC
                            Eng_Up_Flg |= (1 << 11);//对应项标识置位
                        }
                        else
                        {
                            free_mem_block(cmp);    //释放内存块
                            return 1;
                        }
                        if((0x1FFF == (Eng_Up_Flg & 0x1FFF)))   //处理次数指针判别
                        {
                            Eng_Up_Flg = 0;         //标识复位
                            cnt++;
                            cnt %= 0xFFFFFF;        //确保次数指针三字节的取值范围
                            cmp[0] = cnt >> 0;
                            cmp[1] = cnt >> 8;
                            cmp[2] = cnt >> 16;
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算新的CRC
                            cmp[4] = crc >> 8;
                            file_write(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);
                        }
                    }
                    else                                                                //若不同，则认为是首次
                    {
                        base = ENG_LASTXMONTH_00000000_00_HEAD_ADDR + ENG_LASTXMONTH_00000000_00_OFFSET_BLOCKLEN;
                        base += (ENG_MERGED_PHASE_TOT_LEN + ENG_SEPARATE_PHASE_TOT_LEN);//合相关联电能基址
                        crc = calc_crc16(rcv + 8, ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN, 0xFFFF);
                        rcv[8 + ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN] = crc >> 0;   //借用RCV[]末尾2字节
                        rcv[8 + ENG_ALL_RELATOTP_TOT_LEN - CRC_LEN + 1] = crc >> 8;
                        file_write(base, rcv + 8, ENG_ALL_RELATOTP_TOT_LEN);  //保存分、合相关联电能块及CRC
                        Eng_Up_Flg |= (1 << 11);//对应项标识置位

                        if((0x1FFF == (Eng_Up_Flg & 0x1FFF)))   //处理次数指针判别
                        {
                            Eng_Up_Flg = 0;         //标识复位
                            cmp[2] = cmp[1] = cmp[0] = 0;                               //次数设置为0
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算CRC并填充buf
                            cmp[4] = crc >> 8;
                            file_write(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);//保存次数指针
                        }
                    }
                    break;

                default:
                    free_mem_block(cmp);    //释放内存块
                    return -1;
                }
                free_mem_block(cmp);    //释放内存块
                return 1;
            }
            else                //其它设备
            {
                free_mem_block(cmp);    //释放内存块
                return -1;
            }

        case 2:                 //A、B、C各相电能数据块(不包括分相关联电能)
            if(rcv[6] == 9)     //DI5=09:显示终端专属
            {
                switch(rcv[7])  //依据DI6判别:当前或上几个月
                {
                case 0:         //当前[放在内存]
                    base = ENG_MERGED_PHASE_TOT_LEN;  //分相起始下标
                    memcpy(gEngArray + base, rcv + 8, ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN);//保存分相电能量块
                    crc = calc_crc16(gEngArray + base, ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN, 0xFFFF);
                    memcpy(gEngArray + base + ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN, (U8 *)&crc, CRC_LEN);//保存数据
                    break;
                case 1:         //结算日数据[比对保存并更新次数指针]
                    file_read(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);//暂存次数指针及其CRC
                    if(((U16)byte_merge1(cmp + 3, 2) == calc_crc16(cmp, 3, 0xffff)))    //CRC比对:若相同,数据比对
                    {
                        cnt = byte_merge1(cmp, 3);  //获取次数指针

                        base = ENG_LASTXMONTH_00000000_00_HEAD_ADDR + (cnt % 12) * ENG_LASTXMONTH_00000000_00_OFFSET_BLOCKLEN;//cnt%12∈[0,11]
                        base += ENG_MERGED_PHASE_TOT_LEN;                               //A相电能基址
                        file_read(base, cmp, ENG_SEPARATE_PHASE_TOT_LEN);               //分相电能数据块读取

                        if(compare_update_buf(cmp, rcv + 8, ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN))  //比对
                        {
                            crc = calc_crc16 (rcv + 8, ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN, 0xFFFF);
                            cmp[ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN] = crc >> 0;     //借用cmp[]2字节
                            cmp[ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN + 1] = crc >> 8;
                            file_write(base, cmp, ENG_SEPARATE_PHASE_TOT_LEN);//更新外存合相关联电能及数据块CRC
                            Eng_Up_Flg |= (1 << 12);//对应项标识置位
                        }
                        else
                        {
                            free_mem_block(cmp);    //释放内存块
                            return 1;
                        }


                        if((0x1FFF == (Eng_Up_Flg & 0x1FFF)))   //处理次数指针判别
                        {
                            Eng_Up_Flg = 0;         //标识复位
                            cnt++;
                            cnt %= 0xFFFFFF;        //确保次数指针三字节的取值范围
                            cmp[0] = cnt >> 0;
                            cmp[1] = cnt >> 8;
                            cmp[2] = cnt >> 16;
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算新的CRC
                            cmp[4] = crc >> 8;
                            file_write(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);
                        }

                    }
                    else                                                                //若不同，则认为是首次
                    {
                        base = ENG_LASTXMONTH_00000000_00_HEAD_ADDR + ENG_LASTXMONTH_00000000_00_OFFSET_BLOCKLEN;
                        base += ENG_MERGED_PHASE_TOT_LEN;
                        crc = calc_crc16(rcv + 8, ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN, 0xFFFF);
                        rcv[8 + ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN] = crc >> 0; //借用RCV末尾2字节
                        rcv[8 + ENG_SEPARATE_PHASE_TOT_LEN - CRC_LEN + 1] = crc >> 8;
                        file_write(base, rcv + 8, ENG_SEPARATE_PHASE_TOT_LEN);
                        Eng_Up_Flg |= (1 << 12);//对应项标识置位

                        if((0x1FFF == (Eng_Up_Flg & 0x1FFF)))   //处理次数指针判别
                        {
                            Eng_Up_Flg = 0;         //标识复位
                            cmp[2] = cmp[1] = cmp[0] = 0;                               //次数设置为0
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算CRC并填充buf
                            cmp[4] = crc >> 8;
                            file_write(ENG_LASTXMONTH_00000000_00_OFFSET_ADDR, cmp, ENG_LASTXMONTH_00000000_00_OFFSET_LEN);//保存次数指针
                        }
                    }
                    break;

                default:
                    free_mem_block(cmp);    //释放内存块
                    return -1;
                }
                free_mem_block(cmp);    //释放内存块
                return 1;
            }
            else                //其它设备
            {
                free_mem_block(cmp);    //释放内存块
                return -1;
            }

        case 3:                 //A相最大需量及发生时间数据块
            if(rcv[6] == 9)     //DI5=09:显示终端专属
            {
                switch(rcv[7])  //依据DI6判别:当前或上几个月
                {
                case 0:         //当前[内存保存]
                    base = TOTAL_PHASE_DEMAND_LEN * 10;
                    base += (0 * SINGLE_PHASE_DEMAND_LEN);  //A相需量在全局数组的起始下标
                    memcpy(gDmdArray + base, rcv + 8, SINGLE_PHASE_DEMAND_LEN);  //保存数据
                    break;

                case 1:         //结算日数据[比对保存并更新次数指针后判别是否更新外存]
                    file_read(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//借用cmp暂存次数指针及其CRC
                    if(((U16)byte_merge1(cmp + 3, 2) == calc_crc16(cmp, 3, 0xffff)))     //CRC比对:若相同,数据比对
                    {
                        cnt = byte_merge1(cmp, 3);   //获取次数指针

                        base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR + (cnt % 12) * DMD_LASTXMONTH_01010001_00_OFFSET_BLOCKLEN;//cnt%12∈[1,11]
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + 0 * SINGLE_PHASE_DEMAND_LEN);//A相最大需量及发生时间数据块基址
                        file_read(base, cmp, SINGLE_PHASE_DEMAND_LEN);                  //A相最大需量及发生时间数据块读取

                        if(compare_update_buf(cmp, rcv + 8, SINGLE_PHASE_DEMAND_LEN * 10))  //比对
                        {
                            file_write(base, cmp, SINGLE_PHASE_DEMAND_LEN);             //更新外存分相最大需量及发生时间数据块
                            Dmd_Up_Flg |= 1 << 10;
                        }
                        else
                        {
                            free_mem_block(cmp);    //释放内存块
                            return 1;
                        }
#ifdef PHASE_3_LINE_4//PHASE_3_LINE_4
                        if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#else   //PHASE_3_LINE_4
                        if(0x0BFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#endif  //PHASE_3_LINE_4
                        {
                            Dmd_Up_Flg = 0;                     //标识复位
                            cnt++;
                            cnt %= 0xFFFFFF;        //确保次数指针三字节的取值范围
                            cmp[0] = cnt >> 0;
                            cmp[1] = cnt >> 8;
                            cmp[2] = cnt >> 16;
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算新的CRC
                            cmp[4] = crc >> 8;
                            file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);
                        }
                    }
                    else                                                                //若不同，则认为是首次
                    {
                        base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR;
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + 0 * SINGLE_PHASE_DEMAND_LEN);    //A相最大需量及发生时间数据块基址
                        file_write(base, rcv + 8, SINGLE_PHASE_DEMAND_LEN);                     //更新外存分相最大需量及发生时间数据块

#ifdef PHASE_3_LINE_4//PHASE_3_LINE_4
                        if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#else   //PHASE_3_LINE_4
                        if(0x0BFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#endif  //PHASE_3_LINE_4
                        {
                            cmp[2] = cmp[1] = cmp[0] = 0;                               //次数归零
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算CRC并填充buf
                            cmp[4] = crc >> 8;
                            file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//保存次数指针
                        }
                    }
                    break;

                default:
                    free_mem_block(cmp);    //释放内存块
                    return -1;
                }
                free_mem_block(cmp);    //释放内存块
                return 1;
            }
            else                //其它设备
            {
                free_mem_block(cmp);    //释放内存块
                return -1;
            }

        case 4:                 //B相最大需量及发生时间数据块
#ifdef PHASE_3_LINE_4//PHASE_3_LINE_4
            if(rcv[6] == 9)     //DI5=09:显示终端专属
            {
                switch(rcv[7])  //依据DI6判别:当前或上几个月
                {
                case 0:         //当前
                    base = TOTAL_PHASE_DEMAND_LEN * 10;
                    base += (1 * SINGLE_PHASE_DEMAND_LEN);  //B相电量在全局数组的起始下标
                    memcpy(gDmdArray + base, rcv + 8, SINGLE_PHASE_DEMAND_LEN);  //保存数据
                    break;
                case 1:         //结算日数据[比对保存并更新次数指针]
                    file_read(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//借用cmp暂存次数指针及其CRC
                    if(((U16)byte_merge(cmp + 3, 2) == calc_crc16(cmp, 3, 0xffff)))     //CRC比对:若相同,数据比对
                    {
                        cnt = byte_merge(cmp, 3);   //获取次数指针

                        base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR + (cnt % 12) * DMD_LASTXMONTH_01010001_00_OFFSET_BLOCKLEN;//cnt%12∈[1,11]
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + 1 * SINGLE_PHASE_DEMAND_LEN);//B相最大需量及发生时间数据块基址
                        file_read(base, cmp, SINGLE_PHASE_DEMAND_LEN);                      //B相最大需量及发生时间数据块读取

                        if(compare_update_buf(cmp, rcv + 8, SINGLE_PHASE_DEMAND_LEN))   //比对
                        {
                            file_write(base, cmp, SINGLE_PHASE_DEMAND_LEN);             //更新外存合相关联电能
                            Dmd_Up_Flg |= 1 << 11;
                        }
                        else
                        {
                            free_mem_block(cmp);    //释放内存块
                            return 1;
                        }

                        if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
                        {
                            Dmd_Up_Flg = 0;                     //标识复位
                            cnt++;
                            cnt %= 0xFFFFFF;        //确保次数指针三字节的取值范围
                            cmp[0] = cnt >> 0;
                            cmp[1] = cnt >> 8;
                            cmp[2] = cnt >> 16;
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算新的CRC
                            cmp[4] = crc >> 8;
                            file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);
                        }
                    }
                    else                                                                //若不同，则认为是首次
                    {
                        base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR;
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + 1 * SINGLE_PHASE_DEMAND_LEN);    //B相最大需量及发生时间数据块基址
                        file_write(base, rcv + 8, SINGLE_PHASE_DEMAND_LEN);                     //更新外存分相最大需量及发生时间数据块

                        if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
                        {
                            cmp[2] = cmp[1] = cmp[0] = 0;                                   //次数归零
                            cmp[3] = crc = calc_crc16(rcv, 3, 0xffff);                      //计算CRC并填充buf
                            cmp[4] = crc >> 8;
                            file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//保存次数指针
                        }
                    }
                    break;

                default:
                    free_mem_block(cmp);    //释放内存块
                    return -1;
                }
                free_mem_block(cmp);    //释放内存块
                return 1;
            }
            else                //其它设备
            {
                free_mem_block(cmp);    //释放内存块
                return -1;
            }
#else   //PHASE_3_LINE_4
            free_mem_block(cmp);        //释放内存块
            return -1;
#endif  //PHASE_3_LINE_4
        case 5:                 //C相最大需量及发生时间数据块
            if(rcv[6] == 9)     //DI5=09:显示终端专属
            {
                switch(rcv[7])  //依据DI6判别:当前或上几个月
                {
                case 0:         //当前
                    base = TOTAL_PHASE_DEMAND_LEN * 10;
#ifdef PHASE_3_LINE_4
                    base += (2 * SINGLE_PHASE_DEMAND_LEN);  //C相电量在全局数组的起始下标
#else   //PHASE_3_LINE_4
                    base += (1 * SINGLE_PHASE_DEMAND_LEN);  //C相电量在全局数组的起始下标
#endif  //PHASE_3_LINE_4
                    memcpy(gDmdArray + base, rcv + 8, SINGLE_PHASE_DEMAND_LEN);  //保存数据
                    break;
                case 1:         //结算日数据[比对保存并更新次数指针]
                    file_read(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//借用cmp暂存次数指针及其CRC
                    if(((U16)byte_merge(cmp + 3, 2) == calc_crc16(cmp, 3, 0xffff)))     //CRC比对:若相同,数据比对
                    {
                        cnt = byte_merge(cmp, 3);   //获取次数指针

                        base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR + (cnt % 12) * DMD_LASTXMONTH_01010001_00_OFFSET_BLOCKLEN;//cnt%13∈[1,12]
#ifdef PHASE_3_LINE_4
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + 2 * SINGLE_PHASE_DEMAND_LEN);    //C相最大需量及发生时间数据块基址
#else   //PHASE_3_LINE_4
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + 1 * SINGLE_PHASE_DEMAND_LEN);    //C相最大需量及发生时间数据块基址
#endif  //PHASE_3_LINE_4
                        file_read(base, cmp, SINGLE_PHASE_DEMAND_LEN);                          //C相最大需量及发生时间数据块读取

                        if(compare_update_buf(cmp, rcv + 8, SINGLE_PHASE_DEMAND_LEN))           //比对
                        {
                            file_write(base, cmp, SINGLE_PHASE_DEMAND_LEN);                     //更新外存分相最大需量及发生时间数据块
                            Dmd_Up_Flg |= 1 << 12;
                        }

#ifdef PHASE_3_LINE_4
                        if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#else   //PHASE_3_LINE_4
                        if(0x0BFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#endif  //PHASE_3_LINE_4
                        {
                            Dmd_Up_Flg = 0;                     //标识复位
                            cnt++;
                            cnt %= 0xFFFFFF;        //确保次数指针三字节的取值范围
                            cmp[0] = cnt >> 0;
                            cmp[1] = cnt >> 8;
                            cmp[2] = cnt >> 16;
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                  //计算新的CRC
                            cmp[4] = crc >> 8;
                            file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);
                        }
                    }
                    else                                                                //若不同，则认为是首次
                    {

                        base = DMD_LASTXMONTH_01010001_00_HEAD_ADDR;
#ifdef PHASE_3_LINE_4
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + SINGLE_PHASE_DEMAND_LEN * 2);    //C相最大需量及发生时间数据块基址
#else   //PHASE_3_LINE_4
                        base += (TOTAL_PHASE_DEMAND_LEN * 10 + SINGLE_PHASE_DEMAND_LEN * 1);    //C相最大需量及发生时间数据块基址
#endif  //PHASE_3_LINE_4
                        file_write(base, rcv + 8, SINGLE_PHASE_DEMAND_LEN);                     //更新外存分相最大需量及发生时间数据块

#ifdef PHASE_3_LINE_4
                        if(0x0FFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#else   //PHASE_3_LINE_4
                        if(0x0BFF == (Dmd_Up_Flg & 0x0FFF))     //处理次数指针
#endif  //PHASE_3_LINE_4
                        {
                            cmp[2] = cmp[1] = cmp[0] = 0;                                   //次数归零
                            cmp[3] = crc = calc_crc16(cmp, 3, 0xffff);                      //计算CRC并填充buf
                            cmp[4] = crc >> 8;
                            file_write(DMD_LASTXMONTH_01010001_00_OFFSET_ADDR, cmp, DMD_LASTXMONTH_01010001_00_OFFSET_LEN);//保存次数指针
                        }
                    }
                    break;

                default:
                    free_mem_block(cmp);    //释放内存块
                    return -1;
                }
                free_mem_block(cmp);    //释放内存块
                return 1;
            }
            else                //其它设备
            {
                free_mem_block(cmp);    //释放内存块
                return -1;
            }

        default:
            free_mem_block(cmp);    //释放内存块
            return -1;
        }
    }
    else                        //非厂家标识
    {
        return -1;
    }
}
/******************************************************************************
                            End Of File
******************************************************************************/

